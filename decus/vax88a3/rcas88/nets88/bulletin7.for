From:	CSBVAX::MRGATE!MRL%PFC-VAX.MIT.EDU@XX.LCS.MIT.EDU@SMTP 16-MAY-1988 14:57
To:	ARISIA::EVERHART
Subj:	BULLETIN7.FOR


Received: from PFC-VAX.MIT.EDU by MC.LCS.MIT.EDU via Chaosnet; 16 MAY 88  14:24:48 EDT
Date: 16 May 88 14:23:00 EDT
From: MRL%PFC-VAX.MIT.EDU@XX.LCS.MIT.EDU
To: TENCATI@VLSI.JPL.NASA.GOV@MC, MHG@MITRE-BEDFORD.ARPA@MC, 
    EVERHART%ARISIA.DECNET@CRD.GE.COM@MC, GAYMAN@ARI-HQ1.ARPA@MC, 
    BACH@RADC-SOFTVAX@MC
Subject: BULLETIN7.FOR

C
C  BULLETIN7.FOR, Version 4/27/88
C  Purpose: Contains subroutines for the bulletin board utility program.
C  Environment: MIT PFC VAX-11/780, VMS
C  Programmer: Mark R. London
C
	SUBROUTINE UPDATE_LOGIN(ADD_BULL)
C
C  SUBROUTINE UPDATE_LOGIN
C
C  FUNCTION:  Updates the login file when a bulletin has been deleted
C	or added.
C
	IMPLICIT INTEGER (A - Z)

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLUSER.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE '($BRKDEF)'

	INCLUDE '($SSDEF)'

	DIMENSION READ_BTIM_SAVE(2),TEMP_BTIM(2)

	CHARACTER OUTPUT*160,TERMINAL*8
	CHARACTER*1 CR/13/,LF/10/,BELL/7/

C
C  We want to keep the last read date for comparison when selecting new
C  folders, so save it for later restoring.
C

	READ_BTIM_SAVE(1) = READ_BTIM(1)
	READ_BTIM_SAVE(2) = READ_BTIM(2)

	CALL OPEN_FILE_SHARED(4)

C
C  Newest date/time in user file only applies to general bulletins.
C  This was present before adding folder capability.
C  We set flags in user entry to show new folder added for folder bulletins.
C  However, the newest bulletin for each folder is not continually updated,
C  As it is only used when comparing to the last bulletin read time, and to
C  store this for each folder would be too expensive.
C

	TEMP_BTIM(1) = NEWEST_BTIM(1)
	TEMP_BTIM(2) = NEWEST_BTIM(2)
	CALL READ_USER_FILE_HEADER(IER)
	NEWEST_BTIM(1) = TEMP_BTIM(1)
	NEWEST_BTIM(2) = TEMP_BTIM(2)

	IF (IER.NE.0) THEN
	   CALL CLOSE_FILE(4)
	   RETURN
	ELSE IF (FOLDER_NUMBER.EQ.0) THEN
	   CALL SYS_BINTIM(NEWEST_DATE//' '//NEWEST_TIME,NEWEST_BTIM)
	   REWRITE (4,IOSTAT=IER) USER_HEADER
	END IF

C
C  Set flags in all user entries that have SET READNEW on the particular
C  folder to indicate that a new bulletin is present for the particular folder.
C  Also send broadcast if notify flag set.
C
	OUTPUT = BELL//CR//LF//LF//'New bulletin added to folder '//
     &	 FOLDER(1:TRIM(FOLDER))//'. From: '//FROM(1:TRIM(FROM))//
     &   CR//LF//'Description: '//DESCRIP(1:TRIM(DESCRIP))

	IF (ADD_BULL) THEN
	   IF (FOLDER_NUMBER.GT.0) THEN
	      CALL CHKACL
     &		(FOLDER_FILE(1:TRIM(FOLDER_FILE))//'.BULLFIL',IER)
	      IF (IER.EQ.(SS$_ACLEMPTY.OR.SS$_NORMAL)) THEN
	         CHECK_ACL = 0
	      ELSE
	         CHECK_ACL = 1
	      END IF
	   ELSE
	       CHECK_ACL = 0
	   END IF
	END IF

	IF (ADD_BULL) THEN
	 IER = 1
	 DO WHILE (GETUSERS(TEMP_USER,TERMINAL))
	    CALL READ_USER_FILE_KEYNAME(TEMP_USER,IER)
	    IF (IER.EQ.0.AND.TEMP_USER.NE.FROM.AND.
     &	        TEST2(NOTIFY_FLAG,FOLDER_NUMBER)) THEN
	       IF (CHECK_ACL) THEN
	          CALL CHECK_ACCESS
     &			(FOLDER_FILE(1:TRIM(FOLDER_FILE))//'.BULLFIL',
     &			TEMP_USER,IER,WRITE_ACCESS)
	       ELSE
		  IER = 1
	       END IF
	       IF (IER) THEN
		  CALL SYS$BRKTHRU(,OUTPUT(1:TRIM(OUTPUT))//CR,
     &		   TERMINAL(:TRIM(TERMINAL)),%VAL(BRK$C_DEVICE),,,,,,,)
	       ELSE
		  CALL CLR2(NOTIFY_FLAG,FOLDER_NUMBER)
	          REWRITE (4,IOSTAT=IER) TEMP_USER//USER_ENTRY(13:)
	       END IF
	    END IF
	 END DO
	END IF

	CALL READ_USER_FILE_KEYNAME(USERNAME,IER)
		! Reobtain present values as calling programs still uses them

	READ_BTIM(1) = READ_BTIM_SAVE(1)
	READ_BTIM(2) = READ_BTIM_SAVE(2)

	CALL CLOSE_FILE(4)

	RETURN

	END




 
	SUBROUTINE ADD_ENTRY
C
C  SUBROUTINE ADD_ENTRY
C
C  FUNCTION: Enters a new directory entry in the directory file.
C
	IMPLICIT INTEGER (A - Z)
	
	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'

	COMMON /REMOTE_FOLDER/ REMOTE_SET,REMOTE_UNIT
	
	CHARACTER TODAY_TIME*32

	COMMON /COMMAND_LINE/ INCMD
	CHARACTER*132 INCMD

	IF (REMOTE_SET) THEN
	   LOCAL = .TRUE.
	   IF (INCMD(:3).EQ.'ADD') LOCAL = CLI$PRESENT('LOCAL')
	   IF (LOCAL) THEN
	      WRITE (REMOTE_UNIT,'(9A)',IOSTAT=IER)
     &			3,DESCRIP,EXDATE,EXTIME,SYSTEM,0,0,0,0
	   ELSE
	      WRITE (REMOTE_UNIT,'(9A)',IOSTAT=IER)
     &		3,DESCRIP,EXDATE,EXTIME,SYSTEM,CLI$PRESENT('BROADCAST'),
     &		CLI$PRESENT('BELL'),CLI$PRESENT('ALL'),
     &		CLI$PRESENT('CLUSTER')
	   END IF
	   IF (IER.EQ.0) THEN
	      READ(REMOTE_UNIT,'(Q,A)',IOSTAT=IER) I,FOLDER1_COM
	   END IF
	   IF (IER.EQ.0) THEN
	      IF (I.EQ.LEN(FOLDER1_COM)) THEN
	         IER = SYS$ASCTIM(,TODAY_TIME,F1_NEWEST_BTIM,)
	         NEWEST_DATE = TODAY_TIME(1:11)
	         NEWEST_TIME = TODAY_TIME(13:20)
	         NBULL = F1_NBULL
		 CALL UPDATE_FOLDER
	      ELSE
		 WRITE (6,'(1X,A)') FOLDER1_COM(:I)
	      END IF
	   ELSE
	      CALL DISCONNECT_REMOTE
	   END IF
	   CALL UPDATE_LOGIN(.TRUE.)
	   RETURN
	END IF

	CALL SYS$ASCTIM(,TODAY_TIME,,)
	DATE = TODAY_TIME(1:11)
	TIME = TODAY_TIME(13:20)

	CALL READDIR(0,IER)

	IF (IER.NE.1) THEN
	   NEWEST_EXDATE = '5-NOV-2000'
	   NEWEST_EXTIME = '00:00:00'
	   NBULL = 0
	   NBLOCK = 0
	   SHUTDOWN = 0
	   NEMPTY = 0
	END IF

	NEWEST_DATE = DATE
	NEWEST_TIME = TIME

	DIFF = COMPARE_DATE(NEWEST_EXDATE,EXDATE)
	IF (DIFF.GT.0) THEN
	   NEWEST_EXDATE = EXDATE
	   NEWEST_EXTIME = EXTIME
	ELSE IF (DIFF.EQ.0) THEN
	   DIFF = COMPARE_TIME(NEWEST_EXTIME,EXTIME)
	   IF (DIFF.GT.0) NEWEST_EXTIME = EXTIME
	END IF

	NBULL = NBULL + 1
	BLOCK = NBLOCK + 1
	NBLOCK = NBLOCK + LENGTH

	IF ((SYSTEM.AND.4).EQ.4) THEN
	   SHUTDOWN = SHUTDOWN + 1
	   SHUTDOWN_DATE = DATE
	   SHUTDOWN_TIME = TIME
	END IF

	CALL UPDATE_LOGIN(.TRUE.)

	CALL WRITEDIR(NBULL,IER)

	CALL WRITEDIR(0,IER)

	RETURN
	END




	INTEGER FUNCTION COMPARE_BTIM(BTIM1,BTIM2)
C
C  FUNCTION COMPARE_BTIM
C
C  FUCTION: Compares times in binary format to see which is farther in future.
C
C  INPUTS:
C	BTIM1  -  First time in binary format
C	BTIM2  -  Second time in binary format
C  OUTPUT:
C	Returns +1 if first time is farther in future
C	Returns -1 if second time is farther in future
C	Returns 0 if equal time
C
	IMPLICIT INTEGER (A - Z)

	DIMENSION BTIM1(2),BTIM2(2),DIFF(2)

	CALL LIB$SUBX(BTIM1,BTIM2,DIFF)

	IF (DIFF(2).LT.0) THEN
	   COMPARE_BTIM = -1
	ELSE IF (DIFF(2).GE.0) THEN
	   COMPARE_BTIM = +1
	END IF

	RETURN
	END





	INTEGER FUNCTION MINUTE_DIFF(DATE2,DATE1)
C
C  FUNCTION MINUTE_DIFF
C
C  FUNCTION: Finds difference in minutes between 2 binary times.
C
C
	IMPLICIT INTEGER (A-Z)

	DIMENSION DATE1(2),DATE2(2)

	CALL LIB$DAY(DAYS1,DATE1,MSECS1)
	CALL LIB$DAY(DAYS2,DATE2,MSECS2)

	MINUTE_DIFF = (DAYS2-DAYS1)*3600 + (MSECS2-MSECS1)/6000

	RETURN
	END





 
	INTEGER FUNCTION COMPARE_DATE(DATE1,DATE2)
C
C  FUNCTION COMPARE_DATE
C
C  FUCTION: Compares dates to see which is farther in future.
C
C  INPUTS:
C	DATE1  -  First date  (dd-mm-yy)
C	DATE2  -  Second date (If is equal to ' ', then use present date)
C  OUTPUT:
C	Returns the difference in days between the two dates.
C	If the DATE1 is farther in the future, the output is positive,
C	else it is negative.
C
	IMPLICIT INTEGER (A - Z)

	CHARACTER*(*) DATE1,DATE2
	INTEGER USER_TIME(2)

	CALL SYS_BINTIM(DATE1,USER_TIME)

	CALL VERIFY_DATE(USER_TIME)
C
C  LIB$DAY crashes if date invalid, which happened once due to an unknown
C  hardware or software error which created a date very far in the future.
C
	CALL LIB$DAY(DAY1,USER_TIME)

	IF (DATE2.NE.' ') THEN
	   CALL SYS_BINTIM(DATE2,USER_TIME)
	   CALL VERIFY_DATE(USER_TIME)
	ELSE
	   CALL SYS$GETTIM(USER_TIME)
	END IF

	CALL LIB$DAY(DAY2,USER_TIME)

	COMPARE_DATE = DAY1 - DAY2

	RETURN
	END



	SUBROUTINE VERIFY_DATE(BTIM)

	IMPLICIT INTEGER (A-Z)

	DIMENSION BTIM(2),TEMP(2)

	CALL SYS_BINTIM(' 5-NOV-2001 00:00:00.00',TEMP)

	IER = COMPARE_BTIM(BTIM,TEMP)

	IF (IER.GT.0) THEN		! Date invalid
	   BTIM(1) = TEMP(1)V
	   BTIM(2) = TEMP(2)T
	END IFC

	CALL SYS_BINTIM(' 5-NOV-1955 00:00:00.00',TEMP)

	IER = COMPARE_BTIM(BTIM,TEMP)

	IF (IER.LT.0) THEN		! Date invalidL
	   BTIM(1) = TEMP(1)-
	   BTIM(2) = TEMP(2) 
	END IFA

	RETURNT
	END



	INTEGER FUNCTION COMPARE_TIME(TIME1,TIME2)O
CA
C  FUNCTION COMPARE_TIME
C
C  FUCTION: Compares times to see which is farther in future.s
Co
C  INPUTS:
C	TIME1  -  First time	(hh:mm:ss)
C	TIME2  -  Second timeA
C  OUTPUT:
C	Outputs (TIME1-TIME2) in seconds.  Thus, if TIME1 is further
C	in the future, outputs positive number, else negative.
C 

	IMPLICIT INTEGER (A-Z) 
	CHARACTER*(*) TIME1,TIME2
	CHARACTER*23 TODAY_TIME
	CHARACTER*8 TEMP2

	IF (TIME2.EQ.' ') THEN
	   CALL SYS$ASCTIM(,TODAY_TIME,,)
	   TEMP2 = TODAY_TIME(13:20)E
	ELSED
	   TEMP2 = TIME2$
	END IF

	COMPARE_TIME = 3600*10*(ICHAR(TIME1(1:1))-ICHAR(TEMP2(1:1)))*
     &		         +3600*(ICHAR(TIME1(2:2))-ICHAR(TEMP2(2:2)))
     &		        +60*10*(ICHAR(TIME1(4:4))-ICHAR(TEMP2(4:4)))
     &		           +60*(ICHAR(TIME1(5:5))-ICHAR(TEMP2(5:5)))
     &		           +10*(ICHAR(TIME1(7:7))-ICHAR(TEMP2(7:7)))
     &		              +(ICHAR(TIME1(8:8))-ICHAR(TEMP2(8:8)))

	RETURNi
	END

C-------------------------------------------------------------------------
Cl
C  The following are subroutines to create a linked-list queue for e
C  temporary buffer storage of data that is read from files to bet
C  outputted to the terminal.  This is done so as to be able to closet
C  the file as soon as possible.
Ce
C  Each record in the queue has the following format.  The first two
C  words are used for creating a character variable.  The first word
C  contains the length of the character variable, the second contains(
C  the address.  The address is simply the address of the 3rd word ofF
C  the record.  The last word in the record contains the address of theT
C  next record.  Every time a record is written, if that record has a
C  zero link, it adds a new record for the next write operation. t
C  Therefore, there will always be an extra record in the queue.  To
C  check for the end of the queue, the last word (link to next record)
C  is checked to see if it is zero. 
Ce
C-------------------------------------------------------------------------
	SUBROUTINE INIT_QUEUE(HEADER,DATA):
	CHARACTER*(*) DATAS
	IF (HEADER.NE.0) RETURN		! Queue already initializedT
	LENGTH = LEN(DATA) 
	IF (MOD(LENGTH,4).NE.0) LENGTH = LENGTH + 4 - MOD(LENGTH,4)
	CALL LIB$GET_VM(LENGTH+12,HEADER)
	CALL MAKE_CHAR(%VAL(HEADER),LEN(DATA),LENGTH)
	RETURNE
	END


	SUBROUTINE WRITE_QUEUE(RECORD,NEXT,DATA)L
	INTEGER RECORD(1)
	CHARACTER*(*) DATAE
	LENGTH = RECORD(1)L
	CALL COPY_CHAR(LENGTH,DATA,%VAL(%LOC(RECORD)))S
	IF (MOD(LENGTH,4).NE.0) LENGTH = LENGTH + 4 - MOD(LENGTH,4)
	NEXT = RECORD((LENGTH+12)/4)U
	IF (NEXT.NE.0) RETURN
	CALL LIB$GET_VM(LENGTH+12,NEXT)
	CALL MAKE_CHAR(%VAL(NEXT),RECORD(1),LENGTH)
	RECORD((LENGTH+12)/4) = NEXT 
	RETURNO
	END

	SUBROUTINE READ_QUEUE(RECORD,NEXT,DATA)
	CHARACTER*(*) DATAI
	INTEGER RECORD(1)
	LENGTH = RECORD(1) 
	CALL COPY_CHAR(LENGTH,%VAL(%LOC(RECORD)),DATA)S
	IF (MOD(LENGTH,4).NE.0) LENGTH = LENGTH + 4 - MOD(LENGTH,4)
	NEXT = RECORD((LENGTH+12)/4)E
	RETURN
	END

	SUBROUTINE COPY_CHAR(LENGTH,INCHAR,OUTCHAR)
	CHARACTER*(*) INCHAR,OUTCHART
	OUTCHAR = INCHAR(:LENGTH)
	RETURN 
	END

	SUBROUTINE MAKE_CHAR(IARRAY,CHAR_LEN,REAL_LEN)D
	IMPLICIT INTEGER (A-Z)M
	DIMENSION IARRAY(1)
	IARRAY(1) = CHAR_LENg
	IARRAY(2) = %LOC(IARRAY(3))
	IARRAY(REAL_LEN/4+3) = 0A
	RETURNR
	END



	SUBROUTINE DISABLE_PRIVSL
CL
C  SUBROUTINE DISABLE_PRIVSE
C
C  FUNCTION: Disable image high privileges.B
CT

	IMPLICIT INTEGER (A-Z)T

	INCLUDE '($PRVDEF)'

	COMMON /PRIVS/ SETPRV
	DIMENSION SETPRV(2)

	COMMON /PRIVILEGES/ PROCPRIV(2),NEEDPRIV(2)

	CALL SYS$SETPRV(%VAL(0),,,SETPRV)	! Get privilegesE

	SETPRV(1) = SETPRV(1).AND..NOT.PROCPRIV(1)*

	CALL SYS$SETPRV(%VAL(0),SETPRV,,)	! Disable installed privs

	RETURN)
	END



	SUBROUTINE ENABLE_PRIVS
C(
C  SUBROUTINE ENABLE_PRIVS
CN
C  FUNCTION: Enable image high privileges.
C(

	IMPLICIT INTEGER (A-Z)E

	COMMON /PRIVS/ SETPRV
	DIMENSION SETPRV(2)

	CALL SYS$SETPRV(%VAL(1),SETPRV,,)	! Enable image privs)

	RETURN,
	END



	SUBROUTINE CHECK_PRIV_IO(ERROR)
CS
C  SUBROUTINE CHECK_PRIV_IOL
C,
C  FUNCTION: Checks SYS$OUTPUT and SYS$ERROR to see if they need
C	privileges to output to.
CR

	IMPLICIT INTEGER (A-Z)T

	CALL DISABLE_PRIVS			! Disable SYSPRV (

	OPEN (UNIT=6,FILE='SYS$OUTPUT',IOSTAT=IER,STATUS='NEW')
	CLOSE (UNIT=6,STATUS='DELETE')E

	OPEN (UNIT=4,FILE='SYS$ERROR',IOSTAT=IER1,STATUS='NEW')
	IF (IER.NE.0.OR.IER1.NE.0) THEN
	   IF (IER1.EQ.0) WRITE (4,100)
	   IF (IER.EQ.0) WRITE (6,200) 
	   ERROR = 1I
	ELSE(
	   CLOSE (UNIT=4,STATUS='DELETE')
	   ERROR = 0
	END IFL

	CALL ENABLE_PRIVS			! Enable SYSPRV L

100	FORMAT(1X,'ERROR: SYS$OUTPUT cannot be opened.')
200	FORMAT(1X,'ERROR: SYS$ERROR cannot be opened.')T

	RETURN_
	END


	SUBROUTINE CHANGE_FLAG(CMD,FLAG)I
CN
C  SUBROUTINE CHANGE_FLAGT
C 
C  FUNCTION: Sets flags for specified folder. 
CB
C  INPUTS:
C	CMD    -   LOGICAL*4 value. If TRUE, set flag. D
C		   If FALSE, clear flag.
C	FLAG	-  If 1, modify NEW_FLAG, if 2, modify SET_FLAG
C		   If 3, modify BRIEF_FLAG, 4, modify NOTIFY_FLAG
CA
	IMPLICIT INTEGER (A - Z)I

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLUSER.INC'M

	INCLUDE 'BULLFOLDER.INC' 

	DIMENSION FLAGS(FLONG,4)=
	EQUIVALENCE (NEW_FLAG(1),FLAGS(1,1))1

	LOGICAL CMD

	CHARACTER*23 TODAYK
	DIMENSION READ_BTIM_SAVE(2)

	DATA CHANGE_FOLDER /.FALSE./U

	IF (CLI$PRESENT('FOLDER')) THEN
	   IER = CLI$GET_VALUE('FOLDER',FOLDER1)L
	   IF (IER) THENE
	      FOLDER_NUMBER_SAVE = FOLDER_NUMBERR
	      CALL OPEN_FILE_SHARED(7)
	      CALL READ_FOLDER_FILE_KEYNAME_TEMP(FOLDER1,IER)
	      CALL CLOSE_FILE(7)
	      IF (IER.NE.0) THENm
	         WRITE (6,'('' ERROR: No such folder found.'')')
	         RETURN
	      END IFe
	   END IF
	   FOLDER_NUMBER = FOLDER1_NUMBER
	   CHANGE_FOLDER = .TRUE.
	END IF1

Ci
C  Find user entry in BULLUSER.DAT to update information. 
Cf

	ENTRY CHANGE_FLAG_NOCMD(CMD,FLAG)

	CALL OPEN_FILE_SHARED(4)		! Open user fileN

	READ_BTIM_SAVE(1) = READ_BTIM(1)L
	READ_BTIM_SAVE(2) = READ_BTIM(2) 

	CALL READ_USER_FILE_KEYNAME(USERNAME,IER)	! Read old entry.

	IF (IER.GT.0) THEN 		! No entry (how did this happen??)
	   CALL SYS$ASCTIM(,TODAY,,) 
	   CALL SYS_BINTIM(TODAY,LOGIN_BTIM)O
	   CALL SYS_BINTIM('5-NOV-1956 11:05:56',READ_BTIM)	! Fake new entryb
	   CALL READ_USER_FILE_HEADER(IER)E
	   IF (CMD) THENI
	      CALL SET2(FLAGS(1,FLAG),FOLDER_NUMBER)E
	   ELSE
	      CALL CLR2(FLAGS(1,FLAG),FOLDER_NUMBER)_
	   END IF
	   NEW_FLAG(1) = 143-
	   NEW_FLAG(2) = 0R
	   CALL WRITE_USER_FILE_NEW(IER)N
	ELSEO
	   IF (CMD) THENT
	      CALL SET2(FLAGS(1,FLAG),FOLDER_NUMBER)I
	   ELSE
	      CALL CLR2(FLAGS(1,FLAG),FOLDER_NUMBER)
	   END IF
	   NEW_FLAG(1) = 143e
	   REWRITE (4,IOSTAT=IER) USER_ENTRYI
	   READ_BTIM(1) = READ_BTIM_SAVE(1)
	   READ_BTIM(2) = READ_BTIM_SAVE(2)
	END IFa

	CALL CLOSE_FILE (4)

	IF (CHANGE_FOLDER) THEN
	   FOLDER_NUMBER = FOLDER_NUMBER_SAVE
	   CHANGE_FOLDER = .FALSE.
	END IF 

	RETURN-

	END




	SUBROUTINE SET_VERSIONG
CU
C  SUBROUTINE SET_VERSIONI
CM
C  FUNCTION: Sets version number.D
C(
	IMPLICIT INTEGER (A - Z)c

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLUSER.INC' 

	INCLUDE 'BULLFOLDER.INC'w

	DIMENSION FLAGS(FLONG,4)e
	EQUIVALENCE (NEW_FLAG(1),FLAGS(1,1))$

	LOGICAL CMD

	CHARACTER*23 TODAY 
	DIMENSION READ_BTIM_SAVE(2)

C,
C  Find user entry in BULLUSER.DAT to update information.A
CS

	CALL OPEN_FILE_SHARED(4)		! Open user file(

	READ_BTIM_SAVE(1) = READ_BTIM(1)A
	READ_BTIM_SAVE(2) = READ_BTIM(2)

	CALL READ_USER_FILE_KEYNAME(USERNAME,IER)	! Read old entryD

	IF (IER.EQ.0) THEN)
	   NEW_FLAG(1) = 1435
	   REWRITE (4,IOSTAT=IER) USER_ENTRY  ! Write modified entry
	   READ_BTIM(1) = READ_BTIM_SAVE(1)
	   READ_BTIM(2) = READ_BTIM_SAVE(2)
	END IFT

	CALL CLOSE_FILE (4)
	RETURN5

	END





	SUBROUTINE CONFIRM_PRIV(USERNAME,ALLOW)
C
C  SUBROUTINE CONFIRM_PRIV
Cn
C  FUNCTION: Confirms that given username has SETPRV.
CD
C  INPUTS:
C	USERNAME  -  UsernameR
C  OUTPUTS:P
C  	ALLOW     -  Returns 1 if account has SETPRV.E
C		     returns 0 if account has no SETPRV. 
Cf

	IMPLICIT INTEGER (A-Z)I

	CHARACTER*(*) USERNAMEi

	INCLUDE '($PRVDEF)'

	PARAMETER UAF$Q_DEF_PRIV = '1A4'X

	LOGICAL*1 UAF(0:583)s
	EQUIVALENCE (UAF(UAF$Q_DEF_PRIV),UAF_DEF_PRIV)t

	CALL OPEN_FILE_SHARED(8)g
	ALLOW = 0					! Set return falseZ
	READ (8,KEY=USERNAME,IOSTAT=STATUS) UAF		! Read Record
	IF (STATUS.EQ.0) THEN				! If username found
	   IF (BTEST(UAF_DEF_PRIV,PRV$V_SETPRV).OR.	! SETPRV or CMRKNLE
     &	       BTEST(UAF_DEF_PRIV,PRV$V_CMKRNL)) THEN	! privileges?
	      ALLOW = 1					! Yep
	   END IF
	END IF 
	CALL CLOSE_FILE(8)E
	RETURN						! Return)
	END						! End 





	SUBROUTINE CHECK_DISMAIL(USERNAME,DISMAIL)	
C 
C  SUBROUTINE CHECK_DISMAIL-
CA
C  FUNCTION: Checks that given username has DISMAIL.
C-
C  INPUTS:
C	USERNAME  -  Username 
C  OUTPUTS:I
C  	DISMAIL     -  Returns 1 if account has DISMAIL.
C		       returns 0 if account has no DISMAIL.
C-

	IMPLICIT INTEGER (A-Z)T

	CHARACTER*(*) USERNAMEs

	PARAMETER UAF$V_DISMAIL = '7'Xe
	PARAMETER UAF$L_FLAGS = '1D4'Xd

	LOGICAL*1 UAF(0:583)e
	EQUIVALENCE (UAF(UAF$L_FLAGS),UAF_L_FLAGS) 

	CALL OPEN_FILE_SHARED(8)l
	DISMAIL = 0					! Set return false.
	READ (8,KEY=USERNAME,IOSTAT=STATUS) UAF		! Read Recordt
	IF (STATUS.EQ.0) THEN				! If username foundg
	   IF (BTEST(UAF_L_FLAGS,UAF$V_DISMAIL)) THEN	! DISMAIL SET?o
	      DISMAIL = 1				! Yep 
	   END IF
	END IFt
	CALL CLOSE_FILE(8)e
	RETURN						! Returns
	END						! Endo



	INTEGER FUNCTION SYS_TRNLNM(INPUT,OUTPUT)

	IMPLICIT INTEGER (A-Z)

	CHARACTER*(*) INPUT,OUTPUTe

        PARAMETER LNM$_STRING = '2'X

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(LEN(OUTPUT),LNM$_STRING,%LOC(OUTPUT))
	CALL END_ITMLST(TRNLNM_ITMLST)	! Get address of itemlist 

	SYS_TRNLNM = SYS$TRNLNM(,'LNM$FILE_DEV',INPUT(:TRIM(INPUT)),,
     &		%VAL(TRNLNM_ITMLST))

	RETURN-
	END



	INTEGER FUNCTION FILE_LOCK(IER,IER1)-

	IMPLICIT INTEGER (A-Z)E

	INCLUDE '($RMSDEF)'

	DATA INIT /.TRUE./E

	IF (INIT) THENu
	   FILE_LOCK = 1i
	   INIT = .FALSE.
	ELSE
	   IF (IER.GT.0) THEN
	      CALL ERRSNS(IDUMMY,IER1),
	      IF (IER1.EQ.RMS$_FLK) THENE
	         FILE_LOCK = 1H
		 CALL WAIT_SEC('01')
	      ELSEE
	         FILE_LOCK = 0_
	         INIT = .TRUE.
	      END IF(
	   ELSE
	      FILE_LOCK = 0
	      IER1 = 0C
	      INIT = .TRUE.
	   END IF
	END IF)

	RETURND
	END



	SUBROUTINE ENABLE_CTRL-

	IMPLICIT INTEGER (A-Z)O

	COMMON /CTRLY/ CTRLYN

	COMMON /CTRL_LEVEL/ LEVEL

	QUIT = 12

	ENTRY ENABLE_CTRL_EXITL

	QUIT = QUIT.AND.1		! If called via entry, QUIT = 0 
	IF (QUIT.EQ.1) LEVEL = LEVEL - 1D

	IF (LEVEL.LT.0.AND.QUIT.EQ.1) THEN)
	   WRITE (6,'('' ERROR: Error in CTRL.'')')
	END IF 

	IF (LEVEL.EQ.0.OR.QUIT.EQ.0) THEN
	   CALL LIB$ENABLE_CTRL(CTRLY,)	! Enable CTRL-Y & -CD
	END IF)

	IF (QUIT.EQ.0) THEN
	   CALL UPDATE_USERINFO
	   CALL EXITO
	END IFE
	QUIT = 0			! Reinitialize

	RETURNC
	END


	SUBROUTINE DISABLE_CTRL

	IMPLICIT INTEGER (A-Z)B

	COMMON /CTRLY/ CTRLYC

	COMMON /CTRL_LEVEL/ LEVEL
	DATA LEVEL /0/D

	IF (LEVEL.EQ.0) CALL LIB$DISABLE_CTRL(CTRLY,)
	LEVEL = LEVEL + 1

	RETURN(
	END




	SUBROUTINE CLEANUP_BULLFILE
CO
C  SUBROUTINE CLEANUP_BULLFILE
CT
C  FUNCTION:  Searches for empty space in bulletin file and deletes it.
CI
	IMPLICIT INTEGER (A - Z)I

	INCLUDE 'BULLFILES.INC'

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'I

	CHARACTER FILENAME*132,INPUT*128L

	CALL OPEN_FILE_SHARED(2))

Ct
C  NOTE: Can't use READDIR for reading header since it'll spawn a 
C  BULL/CLEANUP.  (Fooey).
C!

	DO WHILE (REC_LOCK(IER))R
	   READ (2'1,IOSTAT=IER) BULLDIR_HEADER
	END DO 

	IF (NEMPTY.EQ.0) THEN		! No cleanup necessary
	 CALL CLOSE_FILE(2)
	 RETURN
	ELSE IF (NEMPTY.GT.0) THENM

	 OPEN (UNIT=11,FILE=FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPFIL',
     1	      STATUS='UNKNOWN',IOSTAT=IER,DISPOSE='DELETE',
     1	      RECORDTYPE='FIXED',RECORDSIZE=32,
     1	      FORM='UNFORMATTED',INITIALSIZE=((NBLOCK-NEMPTY)*128)/512)
				! Compressed version is number 1

	 CALL OPEN_FILE_SHARED(1)		! Open bulletin file

	 NBLOCK = 0

	 DO I=1,NBULL				! Copy bulletins to new file
	   CALL READDIR(I,IER)C
	   ICOUNT = BLOCK
	   DO J=1,LENGTH 
	      NBLOCK = NBLOCK + 1
	      DO WHILE (REC_LOCK(IER1))
	         READ(1'ICOUNT,IOSTAT=IER1) INPUT
	      END DO 
	      IF (IER1.NE.0) THEN		! This file is corrupt
		 NBLOCK = NBLOCK - 1
		 NBULL = I - 1
	         GO TO 100L
	      END IFE
	      WRITE(11) INPUT
	      ICOUNT = ICOUNT + 1
	   END DO
	 END DO

100	 CALL CLOSE_FILE(1)R
	ELSE IF (NEMPTY.EQ.-1) THEN
	 CALL CLOSE_FILE(2)
	 CALL OPEN_FILE(2)	! Open with no sharing
	 IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPFIL',e
     &				'*.BULLFIL')
	 IER = LIB$DELETE_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))// 
     &				'.BULLFIL;-1')
	 IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPDIR',o
     &				'*.BULLDIR')
	 CALL CLOSE_FILE_DELETE(2) 
	 IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.BULL*',
     &				'*.*;1')
	 RETURN
	END IFM

	OPEN (UNIT=12,FILE=FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPDIR',L
     1	      STATUS='UNKNOWN',IOSTAT=IER,DISPOSE='DELETE',
     1	      RECORDTYPE='FIXED',RECORDSIZE=115,ACCESS='DIRECT',R
     1	      ORGANIZATION='RELATIVE',FORM='FORMATTED',
     1	      INITIALSIZE=(((NBULL+1)*115)/512)+1 )

	NEMPTY = 0 
	WRITE (12'1,'(A)',IOSTAT=IER) BULLDIR_HEADER	! Write directory header

	NBLOCK = 0		! Update directory entry pointers
	DO I=1,NBULLm
	   CALL READDIR(I,IER) 
	   BLOCK = NBLOCK + 1
	   WRITE (12'I+1,'(A)',IOSTAT=IER) BULLDIR_ENTRYN
	   NBLOCK = NBLOCK + LENGTH
	END DOR

	CLOSE (UNIT=12,STATUS='KEEP')
	CLOSE (UNIT=11,STATUS='KEEP')

	CALL CLOSE_FILE(2)e
	CALL OPEN_FILE(2)	! Open with no sharingC

	NEMPTY = -1		! Copying done, indicate that in case of crash
	WRITE (2'1,IOSTAT=IER) BULLDIR_HEADER ! Write new directory header 

	IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPFIL',
     &				'*.BULLFIL')
	IER = LIB$DELETE_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//
     &				'.BULLFIL;-1')
	IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.TMPDIR',
     &				'*.BULLDIR')
	CALL CLOSE_FILE_DELETE(2)
	IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))//'.BULL*',_
     &				'*.*;1')

	RETURN 
	END




	SUBROUTINE CLEANUP_DIRFILE(DELETE_ENTRY)L
C1
C  SUBROUTINE CLEANUP_DIRFILE
C 
C  FUNCTION:  Reorder directory file after deletions.E
C	      Is called either directly after a deletion, or isE
C	      called if it is detected that a deletion was not fully
C	      completed due to the fact that the deleting process
C	      was abnormally terminated.
C 
	IMPLICIT INTEGER (A - Z)S

	INCLUDE 'BULLFILES.INC'

	INCLUDE 'BULLDIR.INC'

	NBULL = -NBULL		! Negative # Bulls signals deletion in progress
	MOVE_TO = 0		! Moving directory entries starting here
	MOVE_FROM = 0		! Moving directory entries from here
	I = DELETE_ENTRY	! Start search point for first deleted entries
	DO WHILE (MOVE_TO.EQ.0.AND.I.LE.NBULL)C
	   CALL READDIR(I,IER)I
	   IF (IER.NE.I+1) THEN	! Have we found a deleted entry?U
	      MOVE_TO = I	! If so, start moving entries to here
	      J=I+1		! Search for next entry in file
	      DO WHILE (MOVE_FROM.EQ.0.AND.J.LE.NBULL)e
		 CALL READDIR(J,IER)
		 IF (IER.EQ.J+1) MOVE_FROM = J
		 J = J + 1
	      END DO)
	      IF (MOVE_FROM.EQ.0) THEN	! There are no more entries 
		 NBULL = I - 1		! so just update number of bulletins
		 CALL WRITEDIR(0,IER) 
		 RETURN1
	      END IFE
	      LENGTH = -LENGTH		! Indicate starting point by writingE
	      CALL WRITEDIR(I,IER)	! next entry into deleted entryS
	      FIRST_DELETE = I		! with negative length5
	      MOVE_FROM = MOVE_FROM + 1	! Set up pointers to move rest of
	      MOVE_TO = MOVE_TO + 1	! the entries
	   ELSE IF (LENGTH.LT.0) THEN	! If negative length found, deletion 
	      FIRST_DELETE = I		! was previously in progressi
	      J = I			! Try to find where entry came from
	      DO WHILE (MOVE_FROM.EQ.0.AND.J.LE.NBULL)
		 BLOCK_SAVE = BLOCKM
		 K = J + 1		! Search for duplicate entries
		 DO WHILE (MOVE_FROM.EQ.0.AND.K.LE.NBULL)
		    CALL READDIR(K,IER)_
		    IF (IER.EQ.K+1) THEN
		       IF (BLOCK_SAVE.EQ.BLOCK) THEN
			  MOVE_TO=J+1
			  MOVE_FROM=K+1
		       ELSEU
			  K = K + 1
		       END IFU
		    END IF
		 END DOn
		 J = J + 1		! If no duplicate entry found for this
		 CALL READDIR(J,IER)	! entry, see if one exists for anyV
	      END DO			! of the other entries
	   END IF
	   I = I + 1 
	END DOI

	IF (I.LE.NBULL) THEN		! Move reset of entries if necessaryn
	   IF (MOVE_FROM.GT.0) THEN
	      DO J=MOVE_FROM,NBULL
	         CALL READDIR(J,IER)-
		 IF (IER.EQ.J+1) THEN	! Skip any other deleted entries
		    CALL WRITEDIR(MOVE_TO,IER)
		    MOVE_TO = MOVE_TO + 1I
		 END IF 
	      END DOc
	   END IF
	   DO J=MOVE_TO,NBULL		! Delete empty records at end of fileI
	      DELETE(UNIT=2,REC=J+1,IOSTAT=IER)
	   END DO
	   NBULL = MOVE_TO - 1		! Update # bulletin count
	   CALL READDIR(FIRST_DELETE,IER)
	   LENGTH = -LENGTH		! Fix entry which has negative lengthP
	   CALL WRITEDIR(FIRST_DELETE,IER)!
	END IFr

	CALL WRITEDIR(0,IER)E

	RETURNT
	END


	SUBROUTINE SHOW_FLAGS
CA
C  SUBROUTINE SHOW_FLAGS
Cm
C  FUNCTION: Show user flags.L
C,
	IMPLICIT INTEGER (A - Z)A

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLUSER.INC'E

	INCLUDE 'BULLFOLDER.INC'

CR
C  Find user entry in BULLUSER.DAT to obtain flags.N
CO

	CALL OPEN_FILE_SHARED(4)		! Open user file 

	CALL READ_USER_FILE_KEYNAME(USERNAME,IER)	! Read old entry$

	WRITE (6,'('' For the selected folder '',A)') FOLDER(1:TRIM(FOLDER))T
	T
	IF (TEST2(NOTIFY_FLAG,FOLDER_NUMBER)) THEN 
	   WRITE (6,'('' NOTIFY is set.'')') 
	END IFs

	IF (TEST2(SET_FLAG,FOLDER_NUMBER).AND.E
     &	   (.NOT.TEST2(BRIEF_FLAG,FOLDER_NUMBER))) THEN
	   WRITE (6,'('' READNEW is set.'')')
	ELSE IF (TEST2(BRIEF_FLAG,FOLDER_NUMBER).AND.
     &	       TEST2(SET_FLAG,FOLDER_NUMBER)) THEN
	   WRITE (6,'('' BRIEF is set.'')')
	ELSE IF (TEST2(BRIEF_FLAG,FOLDER_NUMBER).AND.
     &	       .NOT.TEST2(SET_FLAG,FOLDER_NUMBER)) THEN
	   WRITE (6,'('' SHOWNEW is set.'')')
	ELSE IF (.NOT.TEST2(NOTIFY_FLAG,FOLDER_NUMBER)) THENI
	   WRITE (6,'('' No flags are set.'')')
	END IFI

	CALL CLOSE_FILE(4)L

	RETURN
	END


	SUBROUTINE SET2(FLAG,NUMBER) 

	IMPLICIT INTEGER (A-Z)R

	INTEGER FLAG(2)

	F_POINT = NUMBER/32 + 1
	FLAG(F_POINT) = IBSET(FLAG(F_POINT),NUMBER-32*(F_POINT-1))R

	RETURNV
	END


	SUBROUTINE CLR2(FLAG,NUMBER)I

	IMPLICIT INTEGER (A-Z) 

	INTEGER FLAG(2)

	F_POINT = NUMBER/32 + 1
	FLAG(F_POINT) = IBCLR(FLAG(F_POINT),NUMBER-32*(F_POINT-1)) 

	RETURN'
	END



	LOGICAL FUNCTION TEST2(FLAG,NUMBER)

	IMPLICIT INTEGER (A-Z)N

	INTEGER FLAG(2)

	F_POINT = NUMBER/32 + 1
	TEST2 = BTEST(FLAG(F_POINT),NUMBER-32*(F_POINT-1))U

	RETURNN
	END




	INTEGER FUNCTION GETUSERS(USERNAME,TERMINAL)R
CR
C  FUNCTION GETUSERS
C 
C  FUNCTION:
C	To get names of all users that are logged in.L
C

	IMPLICIT INTEGER (A-Z)L

	INCLUDE '($JPIDEF)'

	CHARACTER*(*) USERNAME,TERMINAL

	DATA WILDCARD /-1/L

	CALL INIT_ITMLST	! Initialize item list
				! Now add items to listO
	CALL ADD_2_ITMLST(LEN(USERNAME),JPI$_USERNAME,%LOC(USERNAME))
	CALL ADD_2_ITMLST(LEN(TERMINAL),JPI$_TERMINAL,%LOC(TERMINAL))
	CALL END_ITMLST(GETJPI_ITMLST)	! Get address of itemlist

	IER = 1
	TERMINAL(1:1) = CHAR(0)
	DO WHILE (IER.AND.TERMINAL(1:1).EQ.CHAR(0))
						! Get next interactive process
	   IER = SYS$GETJPIW(,WILDCARD,,%VAL(GETJPI_ITMLST),,,,)L
						! Get next process. 
	END DOC

	IF (.NOT.IER) WILDCARD = -1

	GETUSERS = IERD

	RETURN 
	END





	SUBROUTINE OPEN_USERINFOc
Ca
C  SUBROUTINE OPEN_USERINFOE
CN
C  FUNCTION:  Opens the file in SYS$LOGIN which contains user information.
C_
	IMPLICIT INTEGER (A - Z) 

	INCLUDE 'BULLUSER.INC'T

	COMMON /USERINFO/ USERINFO_READ
	DATA USERINFO_READ /.FALSE./3

	CALL OPEN_FILE_SHARED(9)A

	READ (9,KEY=USERNAME,IOSTAT=IER) USERNAME,	
     &	  ((LAST_READ_BTIM(1,I),LAST_READ_BTIM(2,I)),I=1,FOLDER_MAX)p

	IF (IER.NE.0) THENB
	   OPEN (UNIT=10,FILE='SYS$LOGIN:BULLETIN.INF',STATUS='OLD', 
     &	      RECORDTYPE='FIXED',FORM='UNFORMATTED',IOSTAT=IER)
	   INQUIRE(UNIT=10,RECORDSIZE=INF_SIZE)
	   IF (IER.EQ.0) THEN
	      READ (10)
     &	  ((LAST_READ_BTIM(1,I),LAST_READ_BTIM(2,I)),I=1,INF_SIZE/2)s
	      CLOSE (UNIT=10,STATUS='DELETE')
	   ELSE
	      CALL OPEN_FILE_SHARED(4)		! Get BULLUSER.DAT file
	      CALL READ_USER_FILE_KEYNAME(USERNAME,IER)  ! Find user's info
	      CALL CLOSE_FILE(4) 
	      IF (IER.EQ.0) THENA
	         DO I=1,FOLDER_MAX_
	            LAST_READ_BTIM(1,I) = READ_BTIM(1)E
	            LAST_READ_BTIM(2,I) = READ_BTIM(2)e
	         END DO
	      END IF 
	   END IF
	   IF (IER.EQ.0) WRITE (9) USERNAME,
     &	  ((LAST_READ_BTIM(1,I),LAST_READ_BTIM(2,I)),I=1,FOLDER_MAX)O
	END IF)

	CALL CLOSE_FILE(9)	

	USERINFO_READ = .TRUE.E

	RETURNE
	END



	SUBROUTINE UPDATE_USERINFO(
CI
C  SUBROUTINE UPDATE_USERINFO 
C	
C  FUNCTION:  Updates the latest message read times for each folder.
CO
	IMPLICIT INTEGER (A - Z) 

	COMMON /USERINFO/ USERINFO_READ

	INCLUDE 'BULLUSER.INC'1

	IF (.NOT.USERINFO_READ) RETURNE

	CALL OPEN_FILE_SHARED(9)1

	READ (9,KEY=USERNAME,IOSTAT=IER)F
	IF (IER.EQ.0) REWRITE (9,IOSTAT=IER) USERNAME,1
     &	  ((LAST_READ_BTIM(1,I),LAST_READ_BTIM(2,I)),I=1,FOLDER_MAX)H

	CALL CLOSE_FILE(9) 

	RETURNN
	END


	INTEGER FUNCTION SYS_BINTIM(TIME,BTIM)=

	IMPLICIT INTEGER (A-Z)I

	INTEGER BTIM(2)

	CHARACTER*(*) TIME1

	IF (TRIM(TIME).EQ.20) THEN_
	   SYS_BINTIM = SYS$BINTIM(TIME//'.00',BTIM)
	ELSEE
	   SYS_BINTIM = SYS$BINTIM(TIME,BTIM)
	END IF'

	RETURNC
	END




	SUBROUTINE NEW_MESSAGE_NOTIFICATION
Ch
C  SUBROUTINE NEW_MESSAGE_NOTIFICATION
Ci
C  FUNCTION:
C 
C  Update user's last read bulletin date.  If new bulletins have beenh
C  added since the last time bulletins have been read, position bulletin
C  pointer so that next bulletin read is the first new bulletin, and
C  alert user.  If READNEW set and no new bulletins, just exit.F
CE

	IMPLICIT INTEGER (A-Z)/

	INCLUDE 'BULLFOLDER.INC'D

	INCLUDE 'BULLUSER.INC'T

	COMMON /READIT/ READITE

	COMMON /POINT/ BULL_POINT

	COMMON /SYSTEM_FOLDERS/ SYSTEM_FLAG(FLONG),DUMMY(2)

	COMMON /COMMAND_SWITCHES/ LOGIN_SWITCH,SYSTEM_SWITCHS
	COMMON /COMMAND_SWITCHES/ SYSTEM_LOGIN_BTIM(2)r
	COMMON /COMMAND_SWITCHES/ REVERSE_SWITCH,SEPARATE
	CHARACTER*1 SEPARATEe

	DIMENSION LOGIN_BTIM_SAVE(2)l

	LOGIN_BTIM_SAVE(1) = LOGIN_BTIM(1)s
	LOGIN_BTIM_SAVE(2) = LOGIN_BTIM(2)t
	CALL UPDATE_READ			! Update login time 

	IF (CLI$PRESENT('SELECT_FOLDER')) THEN 
	   CALL SELECT_FOLDER(.TRUE.,IER)
	   IF (IER) RETURN'
	END IFN

	CALL INIT_QUEUE(FOLDER_Q1,FOLDER_COM)
	FOLDER_Q = FOLDER_Q1g

	CALL OPEN_FILE_SHARED(7)		! Go find folders

	DO FOLDER_NUMBER = 0,FOLDER_MAX
	   CALL CLR2(NEW_MSG,FOLDER_NUMBER)	! Clear new message flagh
	   IF ((NEW_FLAG(1).LT.142.OR.NEW_FLAG(1).GT.143).AND..
     &	      TEST2(BRIEF_FLAG,FOLDER_NUMBER).AND.(
     &	      .NOT.TEST2(SET_FLAG,FOLDER_NUMBER)) THEN 
	      CALL CHANGE_FLAG_NOCMD(0,3)
	      CALL SET_VERSIONJ
	   ELSE IF (TEST2(SET_FLAG,FOLDER_NUMBER).OR.
     &		TEST2(BRIEF_FLAG,FOLDER_NUMBER).OR.C
     &		(FOLDER_NUMBER.GT.0.AND.
     &		TEST2(SYSTEM_FLAG,FOLDER_NUMBER).AND.READIT.EQ.1)) THEN_
	      CALL READ_FOLDER_FILE_KEYNUM(FOLDER_NUMBER,IER)
	      IF (IER.NE.0) THENm
		 CALL CHANGE_FLAG_NOCMD(0,2)
		 CALL CHANGE_FLAG_NOCMD(0,3)
		 CALL CHANGE_FLAG_NOCMD(0,4)
		 IF (TEST2(SYSTEM_FLAG,FOLDER_NUMBER)) THENC
		    FOLDER_FLAG = 0e
		    CALL MODIFY_SYSTEM_LIST 
		 END IFD
	      ELSE IF (READIT.EQ.1.AND.SYSTEM_SWITCH.AND.
     &		TEST2(SYSTEM_FLAG,FOLDER_NUMBER)) THEN
	         DIFF = COMPARE_BTIM(SYSTEM_LOGIN_BTIM,
     &					F_NEWEST_BTIM)N
	      ELSEe
	         DIFF = COMPARE_BTIM(LAST_READ_BTIM(1,FOLDER_NUMBER+1),
     &					F_NEWEST_BTIM)I
		 IF (DIFF.LT.0.AND.READIT.EQ.1) THEN
	            DIFF = COMPARE_BTIM(LOGIN_BTIM_SAVE,F_NEWEST_BTIM) 
		 END IFK
	      END IFr
	      IF (DIFF.LT.0.AND.F_NBULL.GT.0) THEN  ! If new unread messages
		 CALL SET2(NEW_MSG,FOLDER_NUMBER)   ! Set new message flag
	         CALL WRITE_QUEUE(%VAL(FOLDER_Q),FOLDER_Q,FOLDER_COM)
	      END IF 
	   END IF
	END DO1

	CALL CLOSE_FILE(7) 

	FOLDER_Q = FOLDER_Q1J

	IF (READIT.EQ.0) THEN 			! If not in READNEW mode
	   IF (TEST2(NEW_MSG,FOLDER_NUMBER)) THEN
	      CALL READ_QUEUE(%VAL(FOLDER_Q),FOLDER_Q,FOLDER_COM)
	   END IF
	   DO FOLDER_NUMBER = 1,FOLDER_MAXT
	      IF (TEST2(NEW_MSG,FOLDER_NUMBER)) THEN 
	         CALL READ_QUEUE(%VAL(FOLDER_Q),FOLDER_Q,FOLDER_COM) 
		 DIFF = COMPARE_BTIM(LAST_READ_BTIM(1,FOLDER_NUMBER+1),o
     &					F_NEWEST_BTIM) 
		 IF (DIFF.LT.0) THEN
		    WRITE (6,'('' There are new messages in folder '',
     &			A,''.'')') FOLDER(1:TRIM(FOLDER))
		    CALL SET2(NEW_MSG,FOLDER_NUMBER)
		 END IFN
	      END IFS
	   END DO
	   FOLDER_NUMBER = 0O
	   CALL SELECT_FOLDER(.FALSE.,IER)
	   DIFF = COMPARE_BTIM(LAST_READ_BTIM(1,FOLDER_NUMBER+1),
     &				F_NEWEST_BTIM)
	   IF (DIFF.LT.0.AND.F_NBULL.GT.0) THEN
	      CALL FIND_NEWEST_BULL	! See if there are new messages
	      IF (BULL_POINT.NE.-1) THENS
	        WRITE(6,'('' Type READ to read new general messages.'')')
		NEW_COUNT = F_NBULL - BULL_POINT
		DIG = 0
		DO WHILE (NEW_COUNT.GT.0)
		   NEW_COUNT = NEW_COUNT / 10
		   DIG = DIG + 1
		END DO
		WRITE(6,'('' There are '',I<DIG>,'' new messages.'')')
     &			F_NBULL - BULL_POINT	! Alert user if new bulletins)
	      ELSEn
	        BULL_POINT = 0r
	        LAST_READ_BTIM(1,FOLDER_NUMBER+1) = F_NEWEST_BTIM(1)T
	        LAST_READ_BTIM(2,FOLDER_NUMBER+1) = F_NEWEST_BTIM(2)Y
		CALL CLR2(NEW_MSG,FOLDER_NUMBER)
	      END IFD
	   END IF
	ELSE				! READNEW mode.
	   DO FOLDER_NUMBER = 0,FOLDER_MAX 
	      IF (TEST2(NEW_MSG,FOLDER_NUMBER)) THEN(
	         CALL READ_QUEUE(%VAL(FOLDER_Q),FOLDER_Q,FOLDER_COM)L
		 CALL CLR2(NEW_MSG,FOLDER_NUMBER)6
		 CALL SELECT_FOLDER(.FALSE.,IER)
		 IF (IER) THEN
	           IF (SYSTEM_SWITCH.AND.
     &		        TEST2(SYSTEM_FLAG,FOLDER_NUMBER)) THEN
	            DIFF = COMPARE_BTIM(SYSTEM_LOGIN_BTIM,F_NEWEST_BTIM)B
		   ELSE
		    DIFF = COMPARE_BTIM(LAST_READ_BTIM(1,FOLDER_NUMBER+1),
     &					F_NEWEST_BTIM)E
		   END IFO
		   IF (DIFF.LT.0) THEN
		    IF (FOLDER_NUMBER.GT.0) CALL LOGIN_FOLDER
	            IF (BULL_POINT.NE.-1) THEN=
		     IF (TEST2(BRIEF_FLAG,FOLDER_NUMBER).AND.R
     &			 TEST2(SET_FLAG,FOLDER_NUMBER)) THENI
		      IF (FOLDER_NUMBER.GT.0) THEN
		       WRITE (6,'('' There are new messages in folder '',R
     &			A,''.'')') FOLDER(1:TRIM(FOLDER))
		      END IF
		     ELSE IF (FOLDER_NUMBER.EQ.0.OR.
     &			.NOT.TEST2(BRIEF_FLAG,FOLDER_NUMBER)) THENF
		       SAVE_BULL_POINT = BULL_POINTF
		       REDO = .TRUE.
		       DO WHILE (REDO)
		          REDO = .FALSE.
		          CALL READNEW(REDO)
			  IF (REDO) CALL REDISPLAY_DIRECTORYO
			  BULL_POINT = SAVE_BULL_POINTt
		       END DO
		     END IF 
		    END IF
		   END IF'
		 ELSE				! Can't select the folder
		    CALL CHANGE_FLAG_NOCMD(0,2)	! then clear SET_FLAGn
		    CALL CHANGE_FLAG_NOCMD(0,3)t
		 END IFO
	      END IFT
	   END DO
	   CALL EXITR
	END IF(

	RETURN
	END




	SUBROUTINE DISCONNECT_REMOTEL

	IMPLICIT INTEGER (A-Z)_

	INCLUDE 'BULLFOLDER.INC'd

	WRITE (6,'('' ERROR: Connection to remote folder disconnected.'')')

	FOLDER_NUMBER = -1H
	FOLDER1 = 'GENERAL'

	CALL SELECT_FOLDER(.FALSE.,IER)

	WRITE (6,'('' Resetting to GENERAL folder.'')')

	RETURNt
	END

