C
C  BULLETIN6.FOR, Version 3/1/88
C  Purpose: Contains subroutines for the bulletin board utility program.
C  Environment: MIT PFC VAX-11/780, VMS
C  Programmer: Mark R. London
C
	SUBROUTINE CRELNM(INPUT,OUTPUT)
	
	IMPLICIT INTEGER (A-Z)

	INCLUDE '($PSLDEF)'

	INCLUDE '($LNMDEF)'

	CHARACTER*(*) INPUT,OUTPUT

	CALL INIT_ITMLST
	CALL ADD_2_ITMLST(LEN(OUTPUT),LNM$_STRING,%LOC(OUTPUT))
	CALL END_ITMLST(CRELNM_ITMLST)

	IER = SYS$CRELNM(,'LNM$PROCESS',INPUT,PSL$C_USER,
     &		%VAL(CRELNM_ITMLST))

	RETURN
	END



	SUBROUTINE GETPRIV
C
C  SUBROUTINE GETPRIV
C
C  FUNCTION:
C	To get process privileges.
C  OUTPUTS:
C	PROCPRIV - Returned privileges
C

	IMPLICIT INTEGER (A-Z)

	COMMON /PRIVILEGES/ PROCPRIV(2),NEEDPRIV(2)

	INCLUDE '($JPIDEF)'

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(8,JPI$_PROCPRIV,%LOC(PROCPRIV))
	CALL END_ITMLST(GETJPI_ITMLST)	! Get address of itemlist

	IER = SYS$GETJPIW(,,,%VAL(GETJPI_ITMLST),,,,) ! Get info

	RETURN
	END




	LOGICAL FUNCTION SETPRV_PRIV
	IMPLICIT INTEGER (A-Z)

	COMMON /PRIVILEGES/ PROCPRIV(2),NEEDPRIV(2)
	DATA NEEDPRIV/0,0/

	INCLUDE '($PRVDEF)'

	INCLUDE 'BULLUSER.INC'

	IF (NEEDPRIV(1).EQ.0.AND.NEEDPRIV(2).EQ.0) THEN
	   CALL OPEN_FILE_SHARED(4)		! Get BULLUSER.DAT file
	   CALL READ_USER_FILE_HEADER(IER)
	   CALL CLOSE_FILE(4)
	   NEEDPRIV(1) = USERPRIV(1)
	   NEEDPRIV(2) = USERPRIV(2)
	END IF

	IF ((PROCPRIV(1).AND.NEEDPRIV(1)).GT.0.OR.
     &	    (PROCPRIV(2).AND.NEEDPRIV(2)).GT.0) THEN
	   SETPRV_PRIV = .TRUE.
	ELSE
	   SETPRV_PRIV = .FALSE.
	END IF

	RETURN
	END



	LOGICAL FUNCTION OPER_PRIV
	IMPLICIT INTEGER (A-Z)
	COMMON /PRIVILEGES/ PROCPRIV(2),NEEDPRIV(2)
	INCLUDE '($PRVDEF)'
	OPER_PRIV = BTEST(PROCPRIV(1),PRV$V_OPER)
	RETURN
	END



 
	SUBROUTINE GETUSER(USERNAME)
C
C  SUBROUTINE GETUSER
C
C  FUNCTION:
C	To get username of present process.
C  OUTPUTS:
C	USERNAME   -   Username owner of present process.
C

	IMPLICIT INTEGER (A-Z)

	CHARACTER*(*) USERNAME		! Limit is 12 characters

	INCLUDE '($JPIDEF)'

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(LEN(USERNAME),JPI$_USERNAME,%LOC(USERNAME))
	CALL END_ITMLST(GETJPI_ITMLST)	! Get address of itemlist

	IER = SYS$GETJPIW(,,,%VAL(GETJPI_ITMLST),,,,) ! Get info

	RETURN
	END



	SUBROUTINE GETACC(ACCOUNT)
C
C  SUBROUTINE GETACC
C
C  FUNCTION:
C	To get account of present process.
C  OUTPUTS:
C	ACCOUNT   -   ACCOUNT owner of present process.
C

	IMPLICIT INTEGER (A-Z)

	CHARACTER*(*) ACCOUNT		! Limit is 12 characters

	INCLUDE '($JPIDEF)'

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(LEN(ACCOUNT),JPI$_ACCOUNT,%LOC(ACCOUNT))
	CALL END_ITMLST(GETJPI_ITMLST)	! Get address of itemlist

	IER = SYS$GETJPIW(,,,%VAL(GETJPI_ITMLST),,,,) ! Get info

	RETURN
	END




	SUBROUTINE GETSTS(STS)
C
C  SUBROUTINE GETSTS
C
C  FUNCTION:
C	To get status of present process. This tells if its a batch process.
C  OUTPUTS:
C	STS   -   Status word of present process.
C

	IMPLICIT INTEGER (A-Z)

	INCLUDE '($JPIDEF)'

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(4,JPI$_STS,%LOC(STS))
	CALL END_ITMLST(GETJPI_ITMLST)	! Get address of itemlist

	IER = SYS$GETJPIW(,,,%VAL(GETJPI_ITMLST),,,,) ! Get info

	RETURN
	END




	SUBROUTINE HELP(LIBRARY)

	IMPLICIT INTEGER (A-Z)
	EXTERNAL LIB$PUT_OUTPUT,LIB$GET_INPUT
	CHARACTER*(*) LIBRARY

	COMMON /BULLPAR/ BULL_PARAMETER,LEN_P
	CHARACTER*64 BULL_PARAMETER

	INCLUDE '($HLPDEF)'

	IER = CLI$GET_VALUE('HELP_FOLDER',BULL_PARAMETER,LEN_P)

	CALL LBR$OUTPUT_HELP(LIB$PUT_OUTPUT,,BULL_PARAMETER(1:LEN_P)
     &		,LIBRARY,HLP$M_HELP.OR.HLP$M_PROMPT,LIB$GET_INPUT)

	RETURN
	END



	INTEGER FUNCTION LNM_MODE_EXEC(FAB,RAB,LUN)

	IMPLICIT INTEGER (A-Z)

	INCLUDE '($FABDEF)'
	INCLUDE '($RABDEF)'

	RECORD /FABDEF/ FAB
	RECORD /RABDEF/ RAB

	FAB.FAB$B_ACMODES = ISHFT(1,FAB$V_LNM_MODE)

	STATUS = SYS$OPEN(FAB)
	IF (STATUS) STATUS = SYS$CONNECT(RAB)

	LNM_MODE_EXEC = STATUS

	END



	INTEGER FUNCTION REC_LOCK(IER)

	INCLUDE '($FORIOSDEF)'

	DATA INIT /.TRUE./

	IF (INIT) THEN
	   REC_LOCK = 1
	   INIT = .FALSE.
	ELSE
	   IF (IER.EQ.FOR$IOS_SPERECLOC) THEN
	      REC_LOCK = 1
	   ELSE
	      REC_LOCK = 0
	      INIT = .TRUE.
	   END IF
	END IF

	RETURN
	END

	INTEGER FUNCTION TRIM(INPUT)
	CHARACTER*(*) INPUT
	DO TRIM=LEN(INPUT),1,-1
	 IF (INPUT(TRIM:TRIM).NE.' '.AND.INPUT(TRIM:TRIM).NE.CHAR(0)) RETURN
	END DO
	RETURN
	END

	SUBROUTINE SYS_GETMSG(IER)

	IMPLICIT INTEGER (A-Z)

	CHARACTER*80 MESSAGE

	CALL LIB$SYS_GETMSG(IER,,MESSAGE)
	WRITE (6,'(A)') MESSAGE

	RETURN
	END



	SUBROUTINE CLOSE_FILE(INPUT)
C
C  SUBROUTINE CLOSE_FILE
C
C  FUNCTION: To close out the bulletin files and enable CTRL-C & -Y
C
C  INPUT:
C	INPUT  -  Unit number of file to close out.
C	          1 = BULLETIN.DAT
C		  2 = BULLDIR.DAT
C		  4 = BULLUSER.DAT
C		  7 = BULLFOLDER.DAT
C		  8 = SYS$SYSTEM:SYSUAF.DAT
C

	CALL ENABLE_CTRL

	CLOSE (UNIT=INPUT)

	RETURN
	END


	SUBROUTINE CLOSE_FILE_DELETE(INPUT)

	IMPLICIT INTEGER (A-Z)

	CALL ENABLE_CTRL

	CLOSE (UNIT=INPUT,STATUS='DELETE')

	RETURN
	END


	SUBROUTINE OPEN_FILE(INPUT)

	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLFILES.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE 'BULLUSER.INC'

	INCLUDE 'BULLDIR.INC'

	INCLUDE '($FORIOSDEF)'

	INCLUDE '($PRVDEF)'

	COMMON /REMOTE_FOLDER/ REMOTE_SET,REMOTE_UNIT

	EXTERNAL BULLDIR_ERR,BULLETIN_ERR,BULLUSER_ERR,BULLFOLDER_ERR
	EXTERNAL BULLINF_ERR

	PARAMETER TIMEOUT = -10*1000*1000*30
	DIMENSION TIMEBUF(2)
	DATA TIMEBUF /TIMEOUT,-1/, TIMEEFN/0/

	IER = 0

	IF (TIMEEFN.EQ.0) CALL LIB$GET_EF(TIMEEFN)

	CALL DISABLE_CTRL		! No breaks while file is open

	IF (INPUT.EQ.2.AND..NOT.REMOTE_SET) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLDIR_ERR,%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=2,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLDIR',STATUS='OLD',IOSTAT=IER,
     &	      RECORDTYPE='FIXED',ACCESS='DIRECT',
     &	      ORGANIZATION='RELATIVE',DISPOSE='KEEP')

	    IF (IER.EQ.FOR$IOS_FILNOTFOU) THEN
	       OPEN (UNIT=2,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	        //'.BULLDIR',STATUS='NEW',
     &	        RECORDTYPE='FIXED',RECORDSIZE=115,ACCESS='DIRECT',
     &	        ORGANIZATION='RELATIVE',DISPOSE='KEEP',
     &	        FORM='FORMATTED',IOSTAT=IER2)
	       CLOSE (UNIT=2)
	       IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	    ELSE IF (IER.EQ.0) THEN
	       INQUIRE(UNIT=2,RECORDSIZE=ASK_SIZE)
	       IF (ASK_SIZE.NE.DIR_RECORD_LENGTH/4) THEN
	          CLOSE (UNIT=2)
	          IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
		  IER = SYS$CANTIM(%VAL(4),)
	          CALL CONVERT_BULLFILES
	          IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLDIR_ERR,
     &					%VAL(4))
	       END IF
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.1.AND..NOT.REMOTE_SET) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLETIN_ERR,%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=1,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLFIL',STATUS='UNKNOWN',IOSTAT=IER,
     &	      ACCESS='DIRECT',RECORDTYPE='FIXED',RECORDSIZE=32,
     &	      FORM='UNFORMATTED')
	    IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	       IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	       IER = SYS$CANTIM(%VAL(4),)
	       CALL CONVERT_BULLFILE
	       IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLETIN_ERR,
     &					%VAL(4))
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.4) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLUSER_ERR,%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=4,FILE=BULLUSER_FILE,STATUS='OLD',
     &	     ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=7+FLONG*4,
     &	     ORGANIZATION='INDEXED',IOSTAT=IER,
     &	     KEY=(1:12:CHARACTER))
	    IF (IER.EQ.FOR$IOS_FILNOTFOU) THEN
	     OPEN (UNIT=4,FILE=BULLUSER_FILE,STATUS='UNKNOWN',
     &	      ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=28+FLONG*16,
     &	      FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER,
     &	      KEY=(1:12:CHARACTER))
	     WRITE (4,FMT=USER_FMT) USER_HEADER_KEY,NEWEST_BTIM,
     &	      BBOARD_BTIM,PRV$M_OPER.OR.PRV$M_CMKRNL.OR.
     &	      PRV$M_SETPRV,(0,I=1,FLONG*4-1)
	     CLOSE (UNIT=4)
	     IDUMMY = FILE_LOCK(IER,IER1)
	    ELSE IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	     IDUMMY = FILE_LOCK(IER,IER1)
	     IER = SYS$CANTIM(%VAL(4),)
	     CALL CONVERT_USERFILE
	     IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLUSER_ERR,
     &					%VAL(4))
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.7) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLFOLDER_ERR,
     &					%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=7,FILE=BULLFOLDER_FILE,STATUS='OLD',
     &	     ACCESS='KEYED',RECORDTYPE='FIXED',
     &	     ORGANIZATION='INDEXED',IOSTAT=IER,
     &	     KEY=(1:25:CHARACTER,26:29:INTEGER))
	    IF (IER.EQ.FOR$IOS_FILNOTFOU) THEN
	      FOLDER1 = 'GENERAL'
	      FOLDER1_OWNER = 'SYSTEM'
	      FOLDER1_DESCRIP = 'Default general bulletin folder.'
	      FOLDER1_BBOARD = 'NONE'
	      FOLDER1_BBEXPIRE = 14
	      NBULL = 0
	      OPEN (UNIT=7,FILE=BULLFOLDER_FILE,STATUS='UNKNOWN',
     &	        ACCESS='KEYED',RECORDTYPE='FIXED',
     &	        RECORDSIZE=FOLDER_RECORD,
     &	        FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER2,
     &	        KEY=(1:25:CHARACTER,26:29:INTEGER))
	      WRITE (7,FMT=FOLDER_FMT,IOSTAT=IER2)
     &		FOLDER1,0,FOLDER1_OWNER,FOLDER1_DESCRIP
     &		,FOLDER1_BBOARD,FOLDER1_BBEXPIRE,USERB,GROUPB,ACCOUNTB
     &		,NBULL,F_NEWEST_BTIM,4,0	! 4 means system folder
	      CLOSE (UNIT=7)
	      IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.9) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLINF_ERR,%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=9,FILE=BULLINF_FILE,STATUS='UNKNOWN',
     &	     ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=FOLDER_MAX*2+3,
     &	     IOSTAT=IER,ORGANIZATION='INDEXED',
     &	     KEY=(1:12:CHARACTER))
	     IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	       IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	       IER = SYS$CANTIM(%VAL(4),)
	       CALL CONVERT_INFFILE
	       IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,BULLINF_ERR,
     &					%VAL(4))
	     END IF
	   END DO
	END IF

	IF (IER.NE.0) THEN
	   WRITE (6,'('' Cannot open unit = '',I)') INPUT
	   IF (IER1.EQ.0) CALL ERRSNS(IDUMMY,IER1)
	   CALL SYS_GETMSG(IER1)
	   CALL ENABLE_CTRL_EXIT	! Enable CTRL-Y & -C & EXIT
	END IF

	IER = SYS$CANTIM(%VAL(4),)		! Successful, so cancel timer.

	RETURN
	END

	SUBROUTINE TIMER_ERR

	IMPLICIT INTEGER (A-Z)

	ENTRY BULLDIR_ERR
	WRITE(6,'('' ERROR: Unable to open directory file after 30 secs.'')')
	GO TO 10

	ENTRY BULLETIN_ERR
	WRITE(6,'('' ERROR: Unable to open message file after 30 secs.'')')
	GO TO 10

	ENTRY BULLUSER_ERR
	WRITE(6,'('' ERROR: Unable to open BULLUSER.DAT after 30 secs.'')')
	GO TO 10

	ENTRY BULLFOLDER_ERR
	WRITE(6,'('' ERROR: Unable to open BULLFOLDER.DAT after 30 secs.'')')
	GO TO 10

	ENTRY BULLINF_ERR
	WRITE(6,'('' ERROR: Unable to open BULLINF.DAT after 30 secs.'')')
	GO TO 10

10	CALL ENABLE_CTRL_EXIT		! No breaks while file is open
	END



	SUBROUTINE OPEN_FILE_SHARED(INPUT)

	IMPLICIT INTEGER (A-Z)

	INCLUDE '($FORIOSDEF)'

	INCLUDE 'BULLFILES.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE 'BULLUSER.INC'

	INCLUDE 'BULLDIR.INC'

	COMMON /POINT/ BULL_POINT

	COMMON /REMOTE_FOLDER/ REMOTE_SET,REMOTE_UNIT

	EXTERNAL LNM_MODE_EXEC,ENABLE_CTRL_EXIT

	PARAMETER TIMEOUT = -10*1000*1000*30
	DIMENSION TIMEBUF(2)
	DATA TIMEBUF /TIMEOUT,-1/, TIMEEFN/0/

	CHARACTER*25 SAVE_FOLDER
	DATA SAVE_BLOCK/-1/

	IER = 0

	IF (TIMEEFN.EQ.0) CALL LIB$GET_EF(TIMEEFN)

	CALL DISABLE_CTRL

	IF (INPUT.EQ.2.AND..NOT.REMOTE_SET) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=2,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLDIR',STATUS='OLD',
     &	      RECORDTYPE='FIXED',ACCESS='DIRECT',
     &	      ORGANIZATION='RELATIVE',DISPOSE='KEEP',
     &	      SHARED,IOSTAT=IER)
	    IF (IER.EQ.FOR$IOS_FILNOTFOU.AND.(FOLDER_NUMBER.EQ.0
     &		.OR.FOLDER.EQ.'GENERAL')) THEN
	       IER2 = LIB$RENAME_FILE(BULLETIN_FILE,'GENERAL.BULLFIL')
	       IER2 = LIB$RENAME_FILE(BULLDIR_FILE,'GENERAL.BULLDIR')
	       IF (IER2) IDUMMY = FILE_LOCK(IER,IER1) ! Don't break out of loop
	    ELSE IF (IER.EQ.0) THEN
	       INQUIRE(UNIT=2,RECORDSIZE=ASK_SIZE)
	       IF (ASK_SIZE.NE.DIR_RECORD_LENGTH/4) THEN
	          CLOSE (UNIT=2)
	          IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
		  IER = SYS$CANTIM(%VAL(4),)
	          CALL CONVERT_BULLFILES
	          IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	       END IF
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.1.AND.REMOTE_SET.AND.(SAVE_BLOCK.NE.BLOCK.OR.
     &		SAVE_FOLDER.NE.FOLDER)) THEN
	   WRITE (REMOTE_UNIT,'(2A)',IOSTAT=IER) 5,BULL_POINT
	   IF (IER.GT.0) THEN
	      CALL ERROR_AND_EXIT
	   ELSE
	      SAVE_BLOCK = BLOCK
	      SAVE_FOLDER = FOLDER
	      CALL GET_REMOTE_MESSAGE(IER)
	      IER = 0
	   END IF
	ELSE IF (INPUT.EQ.1.AND..NOT.REMOTE_SET) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=1,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLFIL',STATUS='OLD',
     &	      ACCESS='DIRECT',RECORDTYPE='FIXED',RECORDSIZE=32,
     &	      FORM='UNFORMATTED',IOSTAT=IER,SHARED)
	    IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	       IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	       IER = SYS$CANTIM(%VAL(4),)
	       CALL CONVERT_BULLFILE
	       IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.4) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=4,FILE=BULLUSER_FILE,STATUS='OLD',
     &	    ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=7+FLONG*4,
     &	    IOSTAT=IER,ORGANIZATION='INDEXED',SHARED,
     &	    KEY=(1:12:CHARACTER))
	    IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	       IDUMMY = FILE_LOCK(IER,IER1)
	       IER = SYS$CANTIM(%VAL(4),)
	       CALL CONVERT_USERFILE
	       IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.7) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=7,FILE=BULLFOLDER_FILE,STATUS='OLD',
     &	    ACCESS='KEYED',RECORDTYPE='FIXED',
     &	    IOSTAT=IER,ORGANIZATION='INDEXED',SHARED,
     &	    KEY=(1:25:CHARACTER,26:29:INTEGER))

	    IF (IER.EQ.0) THEN
	       INQUIRE(UNIT=7,RECORDSIZE=ASK_SIZE)
	       IF (ASK_SIZE.NE.FOLDER_RECORD/4) THEN
	          CLOSE (UNIT=7)
	          IDUMMY = FILE_LOCK(IER,IER1)
	          IER = SYS$CANTIM(%VAL(4),)
	          CALL CONVERT_BULLFOLDER
	          IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	       END IF
	    END IF
	   END DO
	END IF

	IF (INPUT.EQ.8) THEN
	   DO WHILE (FILE_LOCK(IER,IER1))
	    OPEN (UNIT=8,FILE='SYSUAF',DEFAULTFILE='SYS$SYSTEM:SYSUAF.DAT',
     &       ACCESS='KEYED',FORM='UNFORMATTED',ORGANIZATION='INDEXED',
     &       STATUS='OLD',READONLY,IOSTAT=IER,SHARED,
     &	     USEROPEN=LNM_MODE_EXEC)
	   END DO
	END IF

	IF (INPUT.EQ.9) THEN
	   IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,%VAL(4))
	   DO WHILE (FILE_LOCK(IER,IER1))
	     OPEN (UNIT=9,FILE=BULLINF_FILE,STATUS='OLD',
     &	      ACCESS='KEYED',RECORDTYPE='FIXED',
     &	      RECORDSIZE=FOLDER_MAX*2+3,
     &	      IOSTAT=IER,ORGANIZATION='INDEXED',SHARED,
     &	      KEY=(1:12:CHARACTER))
	     IF (IER.EQ.FOR$IOS_INCRECLEN) THEN
	       IDUMMY = FILE_LOCK(IER,IER1)	! Avoid breaking out of DO loop
	       IER = SYS$CANTIM(%VAL(4),)
	       CALL CONVERT_INFFILE
	       IER = SYS$SETIMR(%VAL(TIMEEFN),TIMEBUF,ENABLE_CTRL_EXIT,
     &					%VAL(4))
	     END IF
	   END DO
	END IF

	IF (IER.EQ.FOR$IOS_FILNOTFOU.AND.INPUT.NE.8) THEN
	   CALL SYS$SETDFPROT('FF00'X,CUR_DEF_PROT)
			! Set protection to (SYSTEM:RWE,OWNER:RWE,WORLD,GROUP)
	   CALL OPEN_FILE(INPUT)
	   CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection
	ELSE IF (IER.NE.0) THEN
	   WRITE (6,'('' Cannot open unit = '',I)') INPUT
	   IF (IER1.EQ.0) CALL ERRSNS(IDUMMY,IER1)
	   CALL SYS_GETMSG(IER1)
	   CALL ENABLE_CTRL_EXIT
	END IF

	IER = SYS$CANTIM(%VAL(4),)		! Successful, so cancel timer.

	RETURN
	END




	SUBROUTINE CONVERT_BULLFILES
C
C  SUBROUTINE CONVERT_BULLFILES
C
C  FUNCTION: Converts bulletin files to new format file.
C	Add expiration time to directory file, add extra byte to bulletin
C	file to show where each bulletin starts (for redunancy sake in
C	case crash occurs).
C

	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE 'BULLFILES.INC'

	CHARACTER*81 INPUT

	WRITE (6,'('' Converting data files to new format. Please wait.'')')

	OPEN (UNIT=9,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLDIR',STATUS='OLD',
     &	      RECORDTYPE='FIXED',RECORDSIZE=107,ACCESS='DIRECT',
     &	      ORGANIZATION='RELATIVE',DISPOSE='KEEP',FORM='FORMATTED',
     &	      SHARED,READONLY,IOSTAT=IER)

	IF (IER.NE.0) CALL ERROR_AND_EXIT		! Error.  Why?

	OPEN (UNIT=10,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLFIL',STATUS='OLD',
     &	      RECORDTYPE='FIXED',RECORDSIZE=80,
     &	      FORM='FORMATTED',IOSTAT=IER,SHARED,READONLY)

	IF (IER.NE.0) CALL ERROR_AND_EXIT		! Error.  Why?

	CALL SYS$SETDFPROT('FF00'X,CUR_DEF_PROT)
			! Set protection to (SYSTEM:RWE,OWNER:RWE,WORLD,GROUP)

	OPEN (UNIT=1,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLFIL',STATUS='NEW',IOSTAT=IER,
     &	      ACCESS='DIRECT',RECORDTYPE='FIXED',RECORDSIZE=81,
     &	      FORM='FORMATTED')

	OPEN (UNIT=2,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	      //'.BULLDIR',STATUS='NEW',
     &	      RECORDTYPE='FIXED',RECORDSIZE=115,ACCESS='DIRECT',
     &	      ORGANIZATION='RELATIVE',DISPOSE='KEEP',FORM='FORMATTED',
     &	      IOSTAT=IER)

	NEWEST_EXTIME = '00:00:00'
	READ (9'1,1000,IOSTAT=IER) 
     &		NEWEST_EXDATE,NEWEST_DATE,NEWEST_TIME,
     &		NBULL,NBLOCK,SHUTDOWN,SHUTDOWN_DATE,SHUTDOWN_TIME
	NEMPTY = 0
	IF (IER.EQ.0) CALL WRITEDIR(0,IER1)

	EXTIME = '00:00:00'
	ICOUNT = 2
	DO WHILE (IER.EQ.0)
	   READ(9'ICOUNT,1010,IOSTAT=IER)
     &		DESCRIP,FROM,DATE,TIME,LENGTH,EXDATE,SYSTEM,BLOCK
	   IF (IER.EQ.0) THEN
	      READ(10,'(A)') INPUT
	      WRITE(1,'(A)') INPUT(1:80)//CHAR(1)
	      DO I=2,LENGTH
	         READ(10,'(A)') INPUT
	         WRITE(1,'(A)') INPUT
	      END DO
	      CALL WRITEDIR(ICOUNT-1,IER1)
	      ICOUNT = ICOUNT + 1
	   END IF
	END DO

	CLOSE (UNIT=9)
	CLOSE (UNIT=2)
	CLOSE (UNIT=10)
	CLOSE (UNIT=1)

	CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection
	RETURN

1000	FORMAT(A11,A11,A8,A4,A4,A4,A11,A8)
1010	FORMAT(A53,A12,A11,A8,A4,A11,A4,A4)

	END

	SUBROUTINE CONVERT_BULLFILE
C
C  SUBROUTINE CONVERT_BULLFILE
C
C  FUNCTION: Converts bulletin data file to new format file.
C
C  NOTE: CONVERT_BULLFILES converts from 80 to 81 byte length.
C	 This converts from 81 byte length to 128 compressed format.
C

	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE 'BULLFILES.INC'

	CHARACTER*80 INPUT,NEW_FILE

	WRITE (6,'('' Converting data files to new format. Please wait.'')')

	CALL CLOSE_FILE(2)

	CALL SYS$SETDFPROT('FF00'X,CUR_DEF_PROT)
			! Set protection to (SYSTEM:RWE,OWNER:RWE,WORLD,GROUP)

	CALL OPEN_FILE(7)

100	READ (7,FMT=FOLDER_FMT,ERR=200)
     &		FOLDER,FOLDER_NUMBER,FOLDER_OWNER,FOLDER_DESCRIP
     &		,FOLDER_BBOARD,FOLDER_BBEXPIRE,USERB,GROUPB,ACCOUNTB

	FOLDER_FILE = FOLDER_DIRECTORY(:TRIM(FOLDER_DIRECTORY))
     &		//FOLDER(:TRIM(FOLDER))
	NEW_FILE = FOLDER_FILE(:TRIM(FOLDER_FILE))//'.BULLFILOLD'
	OPEN (UNIT=10,FILE=FOLDER_FILE(:TRIM(FOLDER_FILE))//'.BULLFIL'
     &	      ,STATUS='OLD',
     &	      RECORDTYPE='FIXED',RECORDSIZE=81,ACCESS='DIRECT',
     &	      FORM='FORMATTED',IOSTAT=IER,SHARED,READONLY)

	IF (IER.NE.0) CALL ERROR_AND_EXIT		! Error.  Why?

	OPEN (UNIT=1,FILE=FOLDER_FILE(1:TRIM(FOLDER_FILE))
     &	   //'.BULLFIL',STATUS='NEW',IOSTAT=IER,
     &	   ACCESS='DIRECT',RECORDTYPE='FIXED',RECORDSIZE=32,
     &	   FORM='UNFORMATTED')
	IER = LIB$RENAME_FILE(FOLDER_FILE(:TRIM(FOLDER_FILE))
     &		//'.BULLFIL;-1',NEW_FILE)

	CALL OPEN_FILE(2)

	CALL READDIR(0,IER)

	IF (IER.EQ.1) THEN
	 NBLOCK = 0
	 DO I=1,NBULL
	   CALL READDIR(I,IER)
	   NBLOCK = NBLOCK + 1
	   SBLOCK = NBLOCK
	   DO J=BLOCK,LENGTH+BLOCK-1
	      READ(10'J,'(A)') INPUT
	      ILEN = TRIM(INPUT)
	      IF (ILEN.EQ.0) ILEN = 1
	      CALL STORE_BULL(ILEN,INPUT,NBLOCK)
	   END DO
	   CALL FLUSH_BULL(NBLOCK)
	   LENGTH = NBLOCK - SBLOCK + 1
	   BLOCK = SBLOCK
	   CALL WRITEDIR(I,IER)
	 END DO

	 NEMPTY = 0
	 CALL WRITEDIR(0,IER)
	END IF

	CLOSE (UNIT=10)
	CLOSE (UNIT=1)

	CALL CLOSE_FILE(2)
	GOTO 100

200	CALL OPEN_FILE_SHARED(2)

	CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection

	RETURN

	END



	SUBROUTINE CONVERT_BULLFOLDER
C
C  SUBROUTINE CONVERT_BULLFOLDER
C
C  FUNCTION: Converts bulletin folder file to new format.
C
	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'

	INCLUDE 'BULLFILES.INC'

	INCLUDE '($SSDEF)'

	CHARACTER*80 NEW_FILE

	WRITE (6,'('' Converting data files to new format. Please wait.'')')

	CALL SYS$SETDFPROT('FF00'X,CUR_DEF_PROT)

	EODIR = MAX(INDEX(BULLFOLDER_FILE,':'),INDEX(BULLFOLDER_FILE,']'))
	SUFFIX = INDEX(BULLFOLDER_FILE(EODIR:),'.') + EODIR - 1
	NEW_FILE = BULLFOLDER_FILE(:SUFFIX)//'OLD'
	IER = LIB$RENAME_FILE(BULLFOLDER_FILE,NEW_FILE)

	DO WHILE (FILE_LOCK(IER,IER1))
	   OPEN (UNIT=7,FILE=NEW_FILE,STATUS='OLD',
     &	        ACCESS='KEYED',RECORDTYPE='FIXED',
     &	        FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER,
     &	        KEY=(1:25:CHARACTER,26:29:INTEGER))
	END DO

	IF (IER.NE.0) CALL ERROR_AND_EXIT		! Error.  Why?

	OPEN (UNIT=9,FILE=BULLFOLDER_FILE,STATUS='NEW',
     &	        ACCESS='KEYED',RECORDTYPE='FIXED',
     &	        RECORDSIZE=FOLDER_RECORD,
     &	        FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER,
     &	        KEY=(1:25:CHARACTER,26:29:INTEGER),DISPOSE='DELETE')

	IF (IER.NE.0) CALL ERROR_AND_EXIT		! Error.  Why?

	F_NUMBER = 0
	DO WHILE (IER.EQ.0)
	   READ (7,FMT='(A25,A4,A12,A80,A12,3A4,A8)',
     &			KEYGE=F_NUMBER,KEYID=1,IOSTAT=IER)
     &		FOLDER,F_NUMBER,FOLDER_OWNER,FOLDER_DESCRIP
     &		,FOLDER_BBOARD,FOLDER_BBEXPIRE,USERB,GROUPB,ACCOUNTB
	   IF (IER.EQ.0) THEN
	      FOLDER_FLAG = 0
	      IF (F_NUMBER.EQ.0) FOLDER_FLAG = IBSET(FOLDER_FLAG,2)
	      FOLDER_FILE = FOLDER_DIRECTORY(:TRIM(FOLDER_DIRECTORY))
     &		//FOLDER(:TRIM(FOLDER))
	      CALL CHKACL
     &		(FOLDER_FILE(1:TRIM(FOLDER_FILE))//'.BULLFIL',IER)
	      IF (IER.NE.(SS$_ACLEMPTY.OR.SS$_NORMAL)) THEN
		 FOLDER_FLAG = IBSET(FOLDER_FLAG,0)
	      END IF
	      CALL OPEN_FILE_SHARED(2)
	      CALL READDIR(0,IER)
	      IF (NEWEST_DATE.EQ.'5-NOV-1956 ') THEN
		 IF (NBULL.GT.0) THEN
		    CALL READDIR(NBULL,IER)
		    NEWEST_DATE = DATE
		    NEWEST_TIME = TIME
		    CALL WRITEDIR(0,IER)
		 END IF
	      END IF
	      CALL SYS_BINTIM(NEWEST_DATE//' '//NEWEST_TIME,F_NEWEST_BTIM)
	      WRITE (9,FMT=FOLDER_FMT,IOSTAT=IER)
     &	        FOLDER,F_NUMBER,FOLDER_OWNER,FOLDER_DESCRIP
     &	        ,FOLDER_BBOARD,FOLDER_BBEXPIRE,USERB,GROUPB,ACCOUNTB
     &	        ,NBULL,F_NEWEST_BTIM,FOLDER_FLAG,0
	      CALL CLOSE_FILE(2)
	      F_NUMBER = F_NUMBER + 1
	   END IF
	END DO

	CLOSE (UNIT=7)
	CLOSE (UNIT=9,STATUS='SAVE')

	CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection

	IER = LIB$DELETE_FILE(BBOARD_DIRECTORY(:TRIM(BBOARD_DIRECTORY))
     &		//'BOARD.COM;*')	! BULLETIN$ is referenced in old file

	RETURN
	END

	SUBROUTINE CONVERT_USERFILE
C
C  SUBROUTINE CONVERT_USERFILE
C
C  FUNCTION: Converts user file to new format which has 8 bytes added.
C

	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLFILES.INC'

	INCLUDE 'BULLUSER.INC'

	CHARACTER BUFFER*74,NEW_FILE*80

	CHARACTER*11 LOGIN_DATE,READ_DATE
	CHARACTER*8 LOGIN_TIME,READ_TIME

	WRITE (6,'('' Converting data files to new format. Please wait.'')')

	EODIR = MAX(INDEX(BULLUSER_FILE,':'),INDEX(BULLUSER_FILE,']'))
	SUFFIX = INDEX(BULLUSER_FILE(EODIR:),'.') + EODIR - 1
	NEW_FILE = BULLUSER_FILE(:SUFFIX)//'OLD'
	IER = LIB$RENAME_FILE(BULLUSER_FILE,NEW_FILE)

	OPEN (UNIT=9,FILE=NEW_FILE,STATUS='OLD',
     &	     ACCESS='KEYED',RECORDTYPE='FIXED',
     &	     FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER,
     &	     KEY=(1:12:CHARACTER))
	INQUIRE (UNIT=9,RECORDSIZE=RECL)

	IF ((RECL-28)/16.GT.FLONG) THEN
	   WRITE (6,'('' ERROR: Old data files have more folders'',
     &		      '' than was specified with BULLFOLDER.INC.'')')
	   WRITE (6,'('' Recompile with correct FOLDER_MAX.'')')
	   IF (USERNAME.EQ.'DECNET') THEN
	      CALL SYS$DELPRC(,)
	   ELSE
	      CALL SYS$CANEXH()
	      CALL EXIT
	   END IF
	END IF

	IF (IER.EQ.0) THEN
	   CALL SYS$SETDFPROT('FF00'X,CUR_DEF_PROT)
			! Set protection to (SYSTEM:RWE,OWNER:RWE,WORLD,GROUP)
	   OPEN (UNIT=4,FILE=BULLUSER_FILE,STATUS='NEW',
     &	    ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=28+FLONG*16,
     &	    FORM='FORMATTED',ORGANIZATION='INDEXED',IOSTAT=IER,
     &	    KEY=(1:12:CHARACTER))
	END IF

	IF (IER.NE.0) THEN
	   WRITE (6,'('' Cannot convert user file.'')')
	   IF (IER1.EQ.0) CALL ERRSNS(IDUMMY,IER1)
	   CALL SYS_GETMSG(IER1)
	   CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection
	   CALL ENABLE_CTRL_EXIT
	END IF

	DO I=1,FLONG
	   NEW_FLAG(I) = 'FFFFFFFF'X
	   NOTIFY_FLAG(I) = 0
	   BRIEF_FLAG(I) = 0
	   SET_FLAG(I) = 0
	END DO

	IF (RECL.EQ.42.OR.RECL.EQ.50.OR.RECL.EQ.58.OR.RECL.EQ.66.OR.
     &		RECL.EQ.74) THEN		! Old format
	   IF (RECL.LE.58) RECL = 50
	   IER = 0
	   DO WHILE (IER.EQ.0)
	      READ (9,'(A<RECL>)',IOSTAT=IER) BUFFER
	      IF (IER.EQ.0) THEN
		TEMP_USER = BUFFER(1:12)
	        LOGIN_DATE = BUFFER(13:23)
	        LOGIN_TIME = BUFFER(24:31)
	        READ_DATE = BUFFER(32:42)
	        READ_TIME = BUFFER(43:50)
	        IF (RECL.EQ.58)
     &		  CALL LIB$MOVC3(8,%REF(BUFFER(51:)),SET_FLAG(1))
	        IF (RECL.EQ.66)
     &		  CALL LIB$MOVC3(8,%REF(BUFFER(59:)),NEW_FLAG(1))
	        IF (RECL.EQ.74)
     &		  CALL LIB$MOVC3(8,%REF(BUFFER(67:)),NOTIFY_FLAG(1))
	        CALL SYS_BINTIM(LOGIN_DATE//' '//LOGIN_TIME,LOGIN_BTIM)
	        CALL SYS_BINTIM(READ_DATE//' '//READ_TIME,READ_BTIM)
	        WRITE (4,FMT=USER_FMT) TEMP_USER,LOGIN_BTIM,
     &		READ_BTIM,NEW_FLAG,SET_FLAG,BRIEF_FLAG,NOTIFY_FLAG
	    END IF
	   END DO
	   IF (RECL.LT.66) THEN
	     READ (4,KEY=USER_HEADER_KEY,FMT=USER_FMT) TEMP_USER,
     &		LOGIN_BTIM,
     &		READ_BTIM,NEW_FLAG,SET_FLAG,BRIEF_FLAG,NOTIFY_FLAG
	     NEW_FLAG(1) = PRV$M_OPER.OR.PRV$M_CMKRNL.OR.PRV$M_SETPRV
	     WRITE (4,FMT=USER_FMT) TEMP_USER,LOGIN_BTIM,
     &		READ_BTIM,NEW_FLAG,SET_FLAG,BRIEF_FLAG,NOTIFY_FLAG
	   END IF
	ELSE					! Folder maxmimum increase
	   OFLONG = (RECL - 28) / 16		! Old  #longwords/flag
	   DO WHILE (IER.EQ.0)
	    READ (9,FMT='(A12,<4+OFLONG*4>A4)',IOSTAT=IER) 
     &	     TEMP_USER,LOGIN_BTIM,READ_BTIM,
     &	     (NEW_FLAG(I),I=1,OFLONG),(SET_FLAG(I),I=1,OFLONG),
     &	     (BRIEF_FLAG(I),I=1,OFLONG),(NOTIFY_FLAG(I),I=1,OFLONG)
	    IF (IER.EQ.0) THEN
	     WRITE (4,FMT=USER_FMT) TEMP_USER,LOGIN_BTIM,
     &		READ_BTIM,NEW_FLAG,SET_FLAG,BRIEF_FLAG,NOTIFY_FLAG
	    END IF
	   END DO
	END IF

	IER = 0

	CLOSE (UNIT=9)
	CLOSE (UNIT=4)

	CALL SYS$SETDFPROT(CUR_DEF_PROT,)	! Reset default protection

	RETURN
	END


	SUBROUTINE READDIR(BULLETIN_NUM,ICOUNT)
C
C  SUBROUTINE READDIR
C
C  FUNCTION: Finds the entry for the specified bulletin in the
C	directory file and returns the information for that entry.
C
C  INPUTS:
C	BULLETIN_NUM  -  Bulletin number.  Starts with 1.
C			 If 0, gives header info, i.e number of bulls,
C			 number of blocks in bulletin file, etc.
C  OUTPUTS:
C	ICOUNT  -  The last record read by this routine.
C

	IMPLICIT INTEGER (A - Z)

	INCLUDE 'BULLDIR.INC'

	INCLUDE 'BULLFOLDER.INC'

	COMMON /PROMPT/ COMMAND_PROMPT
	CHARACTER*39 COMMAND_PROMPT

	COMMON /REMOTE_FOLDER/ REMOTE_SET,REMOTE_UNIT

	CHARACTER*2 CFOLDER_NUMBER

	ICOUNT = BULLETIN_NUM

	IF (ICOUNT.EQ.0) THEN
	   IF (.NOT.REMOTE_SET) THEN
	      DO WHILE (REC_LOCK(IER))
	        READ (2'1,IOSTAT=IER) BULLDIR_HEADER
	      END DO
	   ELSE
	      WRITE (REMOTE_UNIT,'(2A)',IOSTAT=IER) 8,0
	      IF (IER.EQ.0) THEN
		 READ (REMOTE_UNIT,'(2A)',IOSTAT=IER) ICOUNT,BULLDIR_HEADER
	      END IF
	      IF (IER.GT.0) THEN
		 CALL ERROR_AND_EXIT
	      ELSE
		 RETURN
	      END IF
	   END IF
	   IF (IER.EQ.0) THEN
	      IF (NBULL.LT.0) THEN	! This indicates bulletin deletion
					! was incomplete.
		 CALL CLOSE_FILE(2)
		 CALL OPEN_FILE(2)
		 CALL CLEANUP_DIRFILE(1)
	      END IF
	      IF (NEMPTY.EQ.'    ') NEMPTY = 0
C
C  Check to see if cleanup of empty file space is necessary, which is
C  defined here as being 50 blocks (200 128byte records).  Also check
C  to see if cleanup was in progress but didn't properly finish.
C
	      IF (NEMPTY.GT.200.AND..NOT.TEST_BULLCP()) THEN
		 WRITE (CFOLDER_NUMBER,'(I2)') FOLDER_NUMBER
	         IER1 = LIB$SPAWN('$'//COMMAND_PROMPT(1:INDEX(
     &		  COMMAND_PROMPT,'>')-1)//'/CLEANUP='//CFOLDER_NUMBER,
     &		  'NL:','NL:',1,'BULL_CLEANUP')
	      ELSE IF (NEMPTY.EQ.-1) THEN
		 CALL CLEANUP_BULLFILE
	      END IF
	   END IF
	ELSE
	   IF (.NOT.REMOTE_SET) THEN
	      DO WHILE (REC_LOCK(IER))
	         READ(2'ICOUNT+1,IOSTAT=IER) BULLDIR_ENTRY
	      END DO
	   ELSE
	      WRITE (REMOTE_UNIT,'(2A)',IOSTAT=IER) 8,ICOUNT
	      IF (IER.EQ.0) THEN
		 READ (REMOTE_UNIT,'(2A)',IOSTAT=IER) ICOUNT,BULLDIR_ENTRY
	      END IF
	      IF (IER.GT.0) THEN
		 CALL ERROR_AND_EXIT
	      ELSE
		 RETURN
	      END IF
	   END IF
	END IF

	IF (IER.EQ.0) ICOUNT = ICOUNT + 1

	UNLOCK 2

	RETURN

	END


	SUBROUTINE WRITEDIR(BULLETIN_NUM,IER)
C
C  SUBROUTINE WRITEDIR
C
C  FUNCTION: Writes the entry for the specified bulletin in the
C	directory file.
C
C  INPUTS:
C	BULLETIN_NUM  -  Bulletin number.  Starts with 1.
C			 If 0, write the header of the directory file.
C  OUTPUTS:
C	IER - Error status from WRITE.
C

	IMPLICIT INTEGER (A - Z)

	COMMON /REMOTE_FOLDER/ REMOTE_SET,REMOTE_UNIT

	INCLUDE 'BULLDIR.INC'
	
	IF (BULLETIN_NUM.EQ.0) THEN
	   WRITE (2'1,IOSTAT=IER) BULLDIR_HEADER
	   IF (REMOTE_SET) THEN
	      WRITE(REMOTE_UNIT,'(3A)',IOSTAT=IER)9,0,BULLDIR_HEADER
	   END IF
	ELSE
	   WRITE (2'BULLETIN_NUM+1,IOSTAT=IER) BULLDIR_ENTRY
	   IF (REMOTE_SET) THEN
	      WRITE(REMOTE_UNIT,'(3A)',IOSTAT=IER)9,BULLETIN_NUM,BULLDIR_ENTRY
	   END IF
	END IF

	IF (REMOTE_SET.AND.IER.GT.0) CALL ERROR_AND_EXIT

	RETURN

	END


	
	SUBROUTINE READACL(FILENAME,ACLENT,ACLLENGTH)
C
C  SUBROUTINE READACL
C
C  FUNCTION: Reads the ACL of a file.
C
C  PARAMETERS:
C	FILENAME - Name of file to check.
C	ACLENT - String which will be large enough to hold ACL information.
C
	IMPLICIT INTEGER (A-Z)

	INCLUDE '($ACLDEF)'

	CHARACTER ACLENT*(*),OUTPUT*80,ACLSTR*255,FILENAME*(*)
	CHARACTER NOT_ID*3
	DATA NOT_ID /'=[,'/

	CALL INIT_ITMLST	! Initialize item list
	CALL ADD_2_ITMLST(ACLLENGTH,ACL$C_READACL,%LOC(ACLENT))
	CALL END_ITMLST(ACL_ITMLST)	! Get address of itemlist

	IER = SYS$CHANGE_ACL(,ACL$C_FILE,FILENAME,%VAL(ACL_ITMLST),,,)

	DO ACCESS_TYPE=1,2
	 POINT = 1
	 OUTLEN = 0
	 DO WHILE ((POINT.LT.ACLLENGTH).AND.IER)
	   IER = SYS$FORMAT_ACL(ACLENT(POINT:POINT-1+
     &		ICHAR(ACLENT(POINT:POINT))),ACLLEN,ACLSTR,,,,)
	   IF ((ACCESS_TYPE.EQ.1.AND.INDEX(ACLSTR,'WRITE').GT.0).OR.
     &	       (ACCESS_TYPE.EQ.2.AND.INDEX(ACLSTR,'READ)').GT.0)) THEN
	      START_ID = INDEX(ACLSTR,'=') + 1
	      END_ID = INDEX(ACLSTR,'ACCESS') - 2
	      IF (ACLSTR(END_ID:END_ID).EQ.']') THEN
		 START_ID = END_ID - 1
		 DO WHILE
     &		   (INDEX(NOT_ID,ACLSTR(START_ID:START_ID)).EQ.0)
		    START_ID = START_ID - 1
		 END DO
		 START_ID = START_ID + 1
		 END_ID = END_ID - 1
		 IF (ACLSTR(START_ID:START_ID).EQ.'*') THEN
		    START_ID = INDEX(ACLSTR,'=') + 1
	            END_ID = INDEX(ACLSTR,'ACCESS') - 2
		 END IF
	      END IF
	      IF (OUTLEN.EQ.0) THEN
	         IF (ACCESS_TYPE.EQ.1) THEN
		    WRITE (6,'(
     &		    '' These users can read and write to this folder:'')')
	         ELSE
		    WRITE (6,'(
     &		    '' These users can only read this folder:'')')
	         END IF
		 OUTLEN = 1
	      END IF
	      IDLEN = END_ID - START_ID + 1
	      IF (OUTLEN+IDLEN-1.GT.80) THEN
		 WRITE (6,'(1X,A)') OUTPUT(:OUTLEN-1)
		 OUTPUT = ACLSTR(START_ID:END_ID)//','
		 OUTLEN = IDLEN + 2
	      ELSE IF (OUTLEN+IDLEN-1.EQ.80) THEN
		 WRITE (6,'(1X,A)') 
     &			OUTPUT(:OUTLEN-1)//ACLSTR(START_ID:END_ID)
	         OUTLEN = 1
	      ELSE
	         OUTPUT(OUTLEN:) = ACLSTR(START_ID:END_ID)//','
		 OUTLEN = OUTLEN + IDLEN + 1
	      END IF
	   END IF
	   POINT = POINT + ICHAR(ACLENT(POINT:POINT))
	 END DO
	 IF (OUTLEN.GT.1) WRITE (6,'(1X,A)') OUTPUT(:OUTLEN-2)
	END DO

	RETURN
	END




	SUBROUTINE CONVERT_INFFILE

	IMPLICIT INTEGER (A-Z)

	INCLUDE 'BULLUSER.INC'

	INCLUDE 'BULLFILES.INC'

	OPEN (UNIT=10,FILE=BULLINF_FILE,STATUS='OLD',
     &	   ACCESS='KEYED',RECORDTYPE='FIXED',
     &	   IOSTAT=IER,ORGANIZATION='INDEXED',
     &	   KEY=(1:12:CHARACTER))

	INQUIRE (UNIT=10,RECORDSIZE=RECL)

	RECL = RECL/8

	OPEN (UNIT=9,FILE=BULLINF_FILE,STATUS='NEW',
     &	   ACCESS='KEYED',RECORDTYPE='FIXED',RECORDSIZE=FOLDER_MAX*2+3,
     &	   IOSTAT=IER,ORGANIZATION='INDEXED',
     &	   KEY=(1:12:CHARACTER))

	DO WHILE (IER.EQ.0)
	 READ (10,IOSTAT=IER) TEMP_USER,((LAST_READ_BTIM(J,I),J=1,2),I=1,RECL)
	 IF (IER.EQ.0) WRITE (9) TEMP_USER,
     &			((LAST_READ_BTIM(J,I),J=1,2),I=1,FOLDER_MAX)
	END DO

	CLOSE (UNIT=10,STATUS='DELETE')

	CLOSE (UNIT=9)

	RETURN
	END


	SUBROUTINE ERROR_AND_EXIT

	IMPLICIT INTEGER (A-Z)
	
	CALL ERRSNS(IDUMMY,IER)
	CALL SYS_GETMSG(IER)
	CALL ENABLE_CTRL_EXIT

	RETURN
	END

