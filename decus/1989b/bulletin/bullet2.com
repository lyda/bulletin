From:	CRDGW2::CRDGW2::MRGATE::"SMTP::PFCVAX.PFC.MIT.EDU::BULLETIN" 21-JUL-1989 10:48
To:	MRGATE::"ARISIA::EVERHART"
Subj:	BULLET2.COM

Message-Id:  <8907211350.AA23820@crdgw1.ge.com>
Received: from PFCVAX.PFC.MIT.EDU by mitvma.mit.edu (IBM VM SMTP R1.2.1MX) with TCP; Fri, 21 Jul 89 09:03:33 EDT
Date: Fri, 21 Jul 89 08:40 EDT
From: BULLETIN@PFCVAX.PFC.MIT.EDU
Subject: BULLET2.COM
To: EVERHART@ARISIA.DECNET
X-Vms-To: IN%"EVERHART%ARISIA.DECNET@CRDGW1.GE.COM"

$set nover
$copy sys$input BOARD_DIGEST.COM
$deck
$!
$! BOARD_DIGEST.COM
$!
$! Command file invoked by folder associated with a BBOARD which is
$! is specified with /SPECIAL.  It will convert "digest" mail and
$! split it into separate messages.  This type of mail is used in
$! certain Arpanet mailing lists, such as TEXHAX and INFO-MAC.
$!
$ FF[0,8] = 12			! Define a form feed character
$ SET PROTECT=(W:RWED)/DEFAULT
$ SET PROC/PRIV=SYSPRV
$ USER := 'F$GETJPI("","USERNAME")
$ EXTRACT_FILE = "BULL_DIR:" + "''USER'" + ".TXT"
$ DEFINE/USER EXTRACT_FILE BULL_DIR:'USER'
$ MAIL
READ
EXTRACT EXTRACT_FILE
DELETE
$ OPEN/READ INPUT 'EXTRACT_FILE'
$ OPEN/WRITE OUTPUT 'EXTRACT_FILE'
$ READ INPUT FROM_USER
$AGAIN:
$ READ/END=ERROR INPUT BUFFER
$ IF F$EXTRACT(0,3,BUFFER) .NES. "To:" THEN GOTO SKIP
$ USER = F$EXTRACT(4,F$LEN(BUFFER),BUFFER)
$ GOTO AGAIN1
$SKIP:
$ IF F$EXTRACT(0,15,BUFFER) .NES. "---------------" THEN GOTO AGAIN
$AGAIN1:
$ READ/END=ERROR INPUT BUFFER
$ IF F$EXTRACT(0,15,BUFFER) .NES. "---------------" THEN GOTO AGAIN1
$ FROM = " "
$ SUBJ = " "
$NEXT:
$ READ/END=EXIT INPUT BUFFER
$FROM:
$ IF F$EXTRACT(0,5,BUFFER) .NES. "From:" THEN GOTO SUBJECT
$ FROM = BUFFER 
$ GOTO NEXT
$SUBJECT:
$ IF F$EXTRACT(0,8,BUFFER) .NES. "Subject:" THEN GOTO NEXT
$ SUBJ = BUFFER - "Subject:"
$F2:
$ IF F$LENGTH(SUBJ) .EQ. 0 THEN GOTO WRITE
$ IF F$EXTRACT(0,1,SUBJ) .NES. " " THEN GOTO WRITE
$ SUBJ = F$EXTRACT(1,F$LENGTH(SUBJ),SUBJ)
$ GOTO F2
$WRITE:
$ WRITE OUTPUT FROM_USER
				! Write From: + TAB + USERNAME
$ WRITE OUTPUT "To:	" + USER
				! Write To: + TAB + BBOARDUSERNAME
$ WRITE OUTPUT "Subj:	" + SUBJ
				! Write Subject: + TAB + mail subject
$ WRITE OUTPUT ""		! Write one blank line
$ IF FROM .NES. " " THEN WRITE OUTPUT FROM
$READ:
$ READ/END=EXIT/ERR=EXIT INPUT BUFFER
$ IF F$EXTRACT(0,15,BUFFER) .EQS. "---------------" THEN GOTO READ1
$ WRITE OUTPUT BUFFER
$ GOTO READ
$READ1:
$ READ/END=EXIT/ERR=EXIT INPUT BUFFER
$ IF F$LOCATE(":",BUFFER) .EQ. F$LENGTH(BUFFER) THEN GOTO READ1
$ WRITE OUTPUT FF
$ FROM = " "
$ SUBJ = " "
$ GOTO FROM
$EXIT:
$ CLOSE INPUT
$ CLOSE OUTPUT
$ PUR 'EXTRACT_FILE'
$ EXIT
$ERROR:
$ CLOSE INPUT
$ CLOSE OUTPUT
$ DELETE 'EXTRACT_FILE';
$eod 
$copy sys$input BOARD_SPECIAL.COM
$deck
$!
$! BOARD_SPECIAL.COM
$!
$! Command file invoked by folder associated with a BBOARD which is
$! is specified with /SPECIAL.  This can be used to convert data to
$! a message via a different means than the VMS mail.  This is done by
$! converting the data to look like output created by the MAIL utility,
$! which appears as follows:
$!
$!	First line is 0 length line.
$!	Second line is "From:" followed by TAB followed by incoming username
$!	Third line is "To:" followed by TAB followed by BBOARD username
$!	Fourth line is "Subj:" followed by TAB followed by subject
$!	The message text then follows.
$!	Message is ended by a line containing a FORM FEED.
$!
$! This command file should be put in the BBOARD_DIRECTORY as specified
$! in BULLFILES.INC.  You can also have several different types of special
$! procedures.  To accomplish this, rename the file to the BBOARD username.
$! i.e. if you specify SET BBOARD FOO/SPECIAL, you could name the file
$! FOO.COM and it will execute that rather than BOARD_SPECIAL.COM.
$!
$! The following routine is the one we use to convert mail from a non-DEC
$! mail network.  The output from this mail is written into a file which
$! is slightly different from the type outputted by MAIL.
$!
$! (NOTE: A username in the SET BBOARD command need only be specified if
$! the process which reads the mail requires that the process be owned by
$! a specific user, which is the case for this sample, and for that matter
$! when reading VMS MAIL.  If this is not required, you do not have to
$! specify a username.)
$!
$ USERNAME := 'F$GETJPI("","USERNAME")'		! This trims trailing spaces
$ IF F$SEARCH("MFE_TELL_FILES:"+USERNAME+".MAI") .EQS. "" THEN EXIT
$ SET DEFAULT BULL_DIR:	! BULLETIN looks for text in BBOARD directory
$ SET PROTECT=(W:RWED)/DEFAULT
$ IF F$SEARCH("MFEMSG.MAI") .NES. "" THEN -
  DELETE MFEMSG.MAI;*		! Delete any leftover output files.
$ MSG := $MFE_TELL: MESSAGE
$ DEFINE/USER SYS$COMMAND SYS$INPUT
$ MSG				! Read MFENET mail
copy * MFEMSG
delete *
exit
$ FF[0,8] = 12			! Define a form feed character
$ OPEN/READ/ERROR=EXIT INPUT MFEMSG.MAI
$ OUTNAME = USERNAME+".TXT"	! Output file will be 'USERNAME'.TXT
$ OPEN/WRITE OUTPUT 'OUTNAME'
$ READ/END=END INPUT DATA		! Skip first line in MSG output
$HEADER:
$ FROM = ""
$ SUBJ = ""
$ MFEMAIL = "T"
$NEXTHEADER:
$ IF (FROM.NES."") .AND. (SUBJ.NES."") THEN GOTO SKIPHEADER
$ READ/END=END INPUT DATA		! Read header line in MSG output
$ IF DATA .EQS. "" THEN GOTO SKIPHEADER	! Missing From or Subj ??
$ IF FROM .NES. "" THEN GOTO SKIPFROM
$ IF F$LOCATE("From: ",DATA) .NES. 0 THEN GOTO 10$
$ MFEMAIL = "F"
$ FROM= F$EXTRACT(6,F$LENGTH(DATA),DATA)
$ GOTO NEXTHEADER
$10$:
$ IF F$LOCATE("Reply-to: ",DATA) .NES. 0 THEN GOTO 20$
$ MFEMAIL = "F"
$ FROM= F$EXTRACT(10,F$LENGTH(DATA),DATA)
$ GOTO NEXTHEADER
$20$:
$ IF F$LOCATE("From ",DATA) .NES. 0 THEN GOTO SKIPFROM
$ FROM= F$EXTRACT(5,F$LENGTH(DATA),DATA)
$ GOTO NEXTHEADER
$SKIPFROM:
$ IF SUBJ .NES. "" THEN GOTO SKIPSUBJ
$ IF F$LOCATE("Subject",DATA) .NES. 0 THEN GOTO SKIPSUBJ
$ SUBJ= F$EXTRACT(F$LOCATE(": ",DATA)+2,F$LENGTH(DATA),DATA)
$ GOTO NEXTHEADER
$SKIPSUBJ:
$ GOTO NEXTHEADER
$SKIPHEADER:
$ WRITE OUTPUT "From:	" + FROM
				! Write From: + TAB + USERNAME
$ WRITE OUTPUT "To:	" + USERNAME
				! Write To: + TAB + BBOARDUSERNAME
$ WRITE OUTPUT "Subj:	" + SUBJ
				! Write Subject: + TAB + mail subject
$ WRITE OUTPUT ""		! Write one blank line
$ IF (DATA.EQS."") .OR. MFEMAIL THEN GOTO SKIPBLANKS
$50$:
$ READ/END=END INPUT DATA		! Skip rest of main header
$ IF DATA .NES. "" THEN GOTO 50$
$60$:
$ READ/END=END INPUT DATA		! Skip all of secondary header
$ IF DATA .NES. "" THEN GOTO 60$
$SKIPBLANKS:
$ READ/END=END INPUT DATA		! Skip all blanks
$ IF DATA .EQS. "" THEN GOTO SKIPBLANKS
$NEXT:				! Read and write message text
$ WRITE OUTPUT DATA
$ IF DATA .EQS. FF THEN GOTO HEADER
			! Multiple messages are seperated by form feeds
$ READ/END=END INPUT DATA
$ GOTO NEXT
$END:
$ CLOSE INPUT
$ CLOSE OUTPUT
$ DELETE MFEMSG.MAI;
$EXIT:
$ EXIT
$eod 
$copy sys$input BULLCOM.CLD
$deck
!
! BULLCOM.CLD
!
! VERSION 6/29/89
!
 	MODULE BULLETIN_SUBCOMMANDS

	DEFINE VERB ADD
		PARAMETER P1, LABEL=FILESPEC, VALUE(TYPE=$FILE)
		QUALIFIER ALL, NONNEGATABLE
		QUALIFIER BELL, NONNEGATABLE
		QUALIFIER BROADCAST, NONNEGATABLE
		DISALLOW NOT BROADCAST AND ALL
		DISALLOW NOT BROADCAST AND BELL
		QUALIFIER CLUSTER, DEFAULT
		QUALIFIER EDIT, NEGATABLE
		QUALIFIER EXPIRATION, NONNEGATABLE, VALUE
		QUALIFIER FOLDER, LABEL=SELECT_FOLDER, VALUE(REQUIRED,LIST)
		QUALIFIER NODES, LABEL=NODES, VALUE(REQUIRED,LIST)
		NONNEGATABLE
		QUALIFIER LOCAL, NONNEGATABLE
		DISALLOW LOCAL AND NOT BROADCAST
		DISALLOW NODES AND SELECT_FOLDER
		QUALIFIER NOINDENT, NONNEGATABLE
		DISALLOW NOINDENT AND NOT TEXT
		QUALIFIER PERMANENT, NONNEGATABLE
		QUALIFIER SHUTDOWN, NONNEGATABLE
		DISALLOW PERMANENT AND SHUTDOWN
		QUALIFIER SUBJECT, NONNEGATABLE, VALUE(REQUIRED)
		QUALIFIER SYSTEM, NONNEGATABLE
		QUALIFIER TEXT, NONNEGATABLE
		DISALLOW TEXT AND NOT EDIT
		DISALLOW TEXT AND FILESPEC
		QUALIFIER USERNAME, LABEL=USERNAME, VALUE(REQUIRED)
		NONNEGATABLE
	DEFINE VERB BACK
	DEFINE VERB CHANGE
		PARAMETER P1, LABEL=FILESPEC, VALUE(TYPE=$FILE):
		QUALIFIER EDIT, NEGATABLEL
		QUALIFIER EXPIRATION, NONNEGATABLE, VALUE:
		QUALIFIER GENERAL, NONNEGATABLEe
		QUALIFIER HEADER, NONNEGATABLE
		QUALIFIER SUBJECT, NONNEGATABLE, VALUE(REQUIRED)
		QUALIFIER NEW,NONNEGATABLE
		QUALIFIER NUMBER, VALUE(TYPE=$NUMBER,REQUIRED)
		QUALIFIER PERMANENT, NONNEGATABLEL
		QUALIFIER SHUTDOWN, NONNEGATABLE
		QUALIFIER SYSTEM,NONNEGATABLEE
		QUALIFIER TEXT, NONNEGATABLE
		DISALLOW NEW AND NOT EDIT
		DISALLOW SYSTEM AND GENERALR
		DISALLOW PERMANENT AND SHUTDOWND
		DISALLOW PERMANENT AND EXPIRATIONe
		DISALLOW SHUTDOWN AND EXPIRATION
		DISALLOW SUBJECT AND HEADERh
	DEFINE VERB COPY 
		PARAMETER P1, LABEL=FOLDER, PROMPT="Folder"p
			VALUE(REQUIRED)
		PARAMETER P2, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER ALLX
		QUALIFIER MERGE
		QUALIFIER ORIGINAL
		DISALLOW ALL AND BULLETIN_NUMBER
	DEFINE VERB CREATET
		QUALIFIER BRIEF, NONNEGATABLE:
		QUALIFIER DESCRIPTION, NONNEGATABLE, VALUE(REQUIRED)
!"
! Make the following qualifier DEFAULT if you want CREATE to be 
! a privileged command.  NOTE: Make sure that BULL_DIR:BULLUSER.DATF
! has the following protection:  (RWED,RWED,,)
!P
		QUALIFIER NEEDPRIV, NONNEGATABLE
		QUALIFIER NODE, NONNEGATABLE, VALUE(REQUIRED)E
		QUALIFIER NOTIFY, NONNEGATABLE
		QUALIFIER OWNER, NONNEGATABLE, VALUE(REQUIRED)
		QUALIFIER PRIVATE, NONNEGATABLER
		QUALIFIER READNEW, NONNEGATABLE 
		QUALIFIER REMOTENAME, NONNEGATABLE, VALUE(REQUIRED)F
		QUALIFIER SEMIPRIVATE, NONNEGATABLE-
		QUALIFIER SHOWNEW, NONNEGATABLE"
		QUALIFIER SYSTEM, NONNEGATABLE
		PARAMETER P1, LABEL=CREATE_FOLDER, PROMPT="Folder"
			VALUE(REQUIRED)
		DISALLOW PRIVATE AND SEMIPRIVATE
		DISALLOW BRIEF AND READNEW
		DISALLOW SHOWNEW AND READNEW
		DISALLOW BRIEF AND SHOWNEW
		DISALLOW NODE AND (NOTIFY OR PRIVATE OR SEMIPRIVATE)
		DISALLOW REMOTENAME AND NOT NODE
	DEFINE VERB CURRENT
		QUALIFIER EDIT
	DEFINE VERB DELETEU
		PARAMETER P1, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER ALLm
		QUALIFIER IMMEDIATE,NONNEGATABLE
		QUALIFIER FOLDER, LABEL=SELECT_FOLDER, VALUE(REQUIRED,LIST)U
		QUALIFIER NODES, LABEL=NODES, VALUE(REQUIRED,LIST)
		QUALIFIER USERNAME, LABEL=USERNAME, VALUE(REQUIRED)
		QUALIFIER SUBJECT, VALUE(REQUIRED)
		DISALLOW NOT SUBJECT AND (NODES OR SELECT_FOLDER)
		DISALLOW NODES AND SELECT_FOLDER
	DEFINE VERB DIRECTORY
		PARAMETER P1, LABEL=SELECT_FOLDERO
		QUALIFIER FOLDER, SYNTAX=DIRECTORY_FOLDER, NONNEGATABLE
		QUALIFIER NEW,
		QUALIFIER START, VALUE(REQUIRED,TYPE=$NUMBER), NONNEGATABLEF
		QUALIFIER SINCE,VALUE(DEFAULT="TODAY",TYPE=$DATETIME)L
		QUALIFIER MARKED, NONNEGATABLE
		DISALLOW (NEW AND SINCE) OR (START AND NEW) OR (START AND SINCE)
	DEFINE SYNTAX DIRECTORY_FOLDERc
		QUALIFIER DESCRIBE
		QUALIFIER FOLDER, DEFAULTA
	DEFINE VERB E				! EXIT command. 
	DEFINE VERB EX				! EXIT command.
	DEFINE VERB EXIT			! EXIT command.h
	DEFINE VERB EXTRACT
		PARAMETER P1, LABEL=FILESPEC, VALUE(TYPE=$FILE,REQUIRED),s
			PROMPT="File"
		PARAMETER P2, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER ALLh
		QUALIFIER HEADER, DEFAULTp
		QUALIFIER NEW, NONNEGATABLEl
		DISALLOW ALL AND BULLETIN_NUMBER
	DEFINE VERB FILEw
		PARAMETER P1, LABEL=FILESPEC, VALUE(TYPE=$FILE,REQUIRED),o
			PROMPT="File"
		PARAMETER P2, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER ALLl
		QUALIFIER HEADER, DEFAULTa
		QUALIFIER NEW, NONNEGATABLEa
		DISALLOW ALL AND BULLETIN_NUMBER
	DEFINE VERB HELPT
		PARAMETER P1, LABEL=HELP_FOLDER, VALUE(TYPE=$REST_OF_LINE)
	DEFINE VERB INDEX
		PARAMETER P1, LABEL=SELECT_FOLDERi
		QUALIFIER MARKED
		QUALIFIER FOLDER, SYNTAX=DIRECTORY_FOLDER, NONNEGATABLEo
		QUALIFIER NEWa
		QUALIFIER RESTARTs
		QUALIFIER START, VALUE(REQUIRED,TYPE=$NUMBER), NONNEGATABLEC
		QUALIFIER SINCE,VALUE(DEFAULT="TODAY",TYPE=$DATETIME).
		DISALLOW (NEW AND SINCE) OR (START AND NEW) OR (START AND SINCE)
	DEFINE VERB LASTi
	DEFINE VERB MAILp
		PARAMETER P1, LABEL=RECIPIENTS, PROMPT="Recipients"l
		VALUE(REQUIRED,IMPCAT,LIST)o
		QUALIFIER HEADER, DEFAULTO
		QUALIFIER SUBJECT, VALUE(REQUIRED)
	DEFINE VERB MODIFYf
		QUALIFIER DESCRIPTIONi
		QUALIFIER NAME, VALUE(REQUIRED) 
		QUALIFIER OWNER, VALUE(REQUIRED)
	DEFINE VERB MOVEc
		PARAMETER P1, LABEL=FOLDER, PROMPT="Folder"e
			VALUE(REQUIRED)
		PARAMETER P2, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER ALL
		QUALIFIER MERGET
		QUALIFIER NODES	
		QUALIFIER ORIGINAL
		QUALIFIER IMMEDIATE,NONNEGATABLE,DEFAULT
		DISALLOW ALL AND BULLETIN_NUMBER
		DISALLOW FOLDER AND NODESL
	DEFINE VERB NEXT 
	DEFINE VERB POST
		QUALIFIER CC, VALUE(LIST,REQUIRED)
		QUALIFIER LIST, DEFAULTS
		QUALIFIER SUBJECT, VALUE(REQUIRED)
		QUALIFIER NOINDENT, NONNEGATABLE
		DISALLOW NOINDENT AND NOT TEXT
		QUALIFIER TEXT
		QUALIFIER EDIT
		DISALLOW TEXT AND NOT EDIT
	DEFINE VERB PRINT
		PARAMETER P1, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
		QUALIFIER HEADER, DEFAULTT
		QUALIFIER NOTIFY, DEFAULTR
		QUALIFIER QUEUE, VALUE(DEFAULT=SYS$PRINT), NONNEGATABLEI
                QUALIFIER FORM, VALUE, NONNEGATABLEi
                QUALIFIER ALLA
		DISALLOW ALL AND BULLETIN_NUMBER
	DEFINE VERB QUITX
	DEFINE VERB READM
		PARAMETER P1, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$NUMBER)
		QUALIFIER EDIT
		QUALIFIER MARKED, NONNEGATABLE
		QUALIFIER NEW 
		QUALIFIER PAGE, DEFAULTi
		QUALIFIER SINCE,VALUE(DEFAULT="TODAY",TYPE=$DATETIME)F
		DISALLOW NEW AND SINCE
	DEFINE VERB REPLY
		PARAMETER P1, LABEL=FILESPEC, VALUE(TYPE=$FILE)$
		QUALIFIER ALL, NONNEGATABLEH
		QUALIFIER BELL, NONNEGATABLE
		QUALIFIER BROADCAST, NONNEGATABLE$
		DISALLOW NOT BROADCAST AND ALL
		DISALLOW NOT BROADCAST AND BELLO
		QUALIFIER CLUSTER, DEFAULT
		QUALIFIER EDIT, NEGATABLEH
		QUALIFIER EXPIRATION, NONNEGATABLE, VALUEH
		QUALIFIER FOLDER, LABEL=SELECT_FOLDER, VALUE(REQUIRED,LIST)"
		QUALIFIER NODES, LABEL=NODES, VALUE(REQUIRED,LIST)
		NONNEGATABLE
		QUALIFIER LOCAL$
		DISALLOW LOCAL AND NOT BROADCAST
		DISALLOW NODES AND SELECT_FOLDER
		QUALIFIER NOINDENT, NONNEGATABLE
		DISALLOW NOINDENT AND NOT TEXT
		QUALIFIER PERMANENT, NONNEGATABLER
		QUALIFIER SHUTDOWN, NONNEGATABLE
		DISALLOW PERMANENT AND SHUTDOWNS
		QUALIFIER SUBJECT, NONNEGATABLE, VALUE(REQUIRED)
		QUALIFIER SYSTEM, NONNEGATABLE
		QUALIFIER TEXT, NONNEGATABLE
		DISALLOW TEXT AND NOT EDIT
		DISALLOW TEXT AND FILESPEC
		QUALIFIER USERNAME, LABEL=USERNAME, VALUE(REQUIRED)a
		NONNEGATABLE
	DEFINE VERB REMOVEO
		PARAMETER P1, LABEL=REMOVE_FOLDER, PROMPT="Folder"
			VALUE(REQUIRED)
	DEFINE VERB RESPOND
		QUALIFIER CC, VALUE(LIST,REQUIRED)
		QUALIFIER LIST
		QUALIFIER SUBJECT, VALUE(REQUIRED)
		QUALIFIER NOINDENT, NONNEGATABLE
		DISALLOW NOINDENT AND NOT TEXT
		QUALIFIER TEXT
		QUALIFIER EDIT
		DISALLOW TEXT AND NOT EDIT
	DEFINE VERB SEARCHt
		PARAMETER P1, LABEL=SEARCH_STRINGT
		QUALIFIER START, VALUE(TYPE=$NUMBER,REQUIRED)L
		QUALIFIER SUBJECTM
	DEFINE VERB SELECT 
		PARAMETER P1, LABEL=SELECT_FOLDER.
		QUALIFIER MARKED, NONNEGATABLE
	DEFINE VERB SET
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"N
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		QUALIFIER ID
	DEFINE TYPE SET_OPTIONS
		KEYWORD NODE, SYNTAX=SET_NODE 
		KEYWORD NONODE, SYNTAX = SET_NONODEN
		KEYWORD EXPIRE_LIMIT, SYNTAX=SET_EXPIREL
		KEYWORD NOEXPIRE_LIMIT
		KEYWORD GENERIC, SYNTAX=SET_GENERICT
		KEYWORD NOGENERIC, SYNTAX=SET_GENERICE
		KEYWORD LOGIN, SYNTAX=SET_LOGIN
		KEYWORD NOLOGIN, SYNTAX=SET_LOGINE
		KEYWORD NOBBOARD
		KEYWORD BBOARD, SYNTAX=SET_BBOARD 
		KEYWORD NOBRIEF, SYNTAX=SET_NOFLAGS	
		KEYWORD BRIEF, SYNTAX=SET_FLAGSI
		KEYWORD NOSHOWNEW, SYNTAX=SET_NOFLAGSW
		KEYWORD SHOWNEW, SYNTAX=SET_FLAGS 
		KEYWORD NOREADNEW, SYNTAX=SET_NOFLAGSN
		KEYWORD READNEW, SYNTAX=SET_FLAGS,
		KEYWORD ACCESS, SYNTAX=SET_ACCESS 
		KEYWORD NOACCESS, SYNTAX=SET_NOACCESSU
		KEYWORD FOLDER, SYNTAX=SET_FOLDERA
		KEYWORD NOTIFY, SYNTAX=SET_FLAGS
		KEYWORD NONOTIFY, SYNTAX=SET_NOFLAGS
		KEYWORD PRIVILEGES, SYNTAX=SET_PRIVILEGESI
		KEYWORD DUMP
		KEYWORD NODUMP
		KEYWORD PAGE
		KEYWORD NOPAGE
		KEYWORD SYSTEM
		KEYWORD NOSYSTEM
		KEYWORD KEYPAD
		KEYWORD NOKEYPAD
		KEYWORD PROMPT_EXPIREC
		KEYWORD NOPROMPT_EXPIREL
		KEYWORD DEFAULT_EXPIRE, SYNTAX=SET_DEFAULT_EXPIREG
		KEYWORD STRIP	
		KEYWORD NOSTRIPN
		KEYWORD DIGEST
		KEYWORD NODIGEST
	DEFINE SYNTAX SET_NODEJ
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"E
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=NODENAME, VALUE(REQUIRED),
		PARAMETER P3, LABEL=REMOTENAME
		QUALIFIER FOLDER, VALUE(REQUIRED)N
	DEFINE SYNTAX SET_NONODEE
		QUALIFIER FOLDER, VALUE(REQUIRED)N
	DEFINE SYNTAX SET_EXPIRE 
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=EXPIRATION, VALUE(TYPE=$NUMBER,REQUIRED)
	DEFINE SYNTAX SET_GENERIC
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"L
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=USERNAME, VALUE(REQUIRED)X
		QUALIFIER DAYS,VALUE(TYPE=$NUMBER,DEFAULT="7"),DEFAULT
	DEFINE SYNTAX SET_LOGIN
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What":
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=USERNAME, VALUE(REQUIRED)i
	DEFINE SYNTAX SET_FLAGS
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What" 
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		QUALIFIER DEFAULT, NONNEGATABLER
		QUALIFIER ALL, NONNEGATABLEV
		QUALIFIER CLUSTER, DEFAULT
		QUALIFIER FOLDER, VALUE(REQUIRED)	
		DISALLOW NOT ALL AND NOT DEFAULT AND CLUSTER
		DISALLOW ALL AND DEFAULT
	DEFINE SYNTAX SET_NOFLAGS
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		QUALIFIER DEFAULT, NONNEGATABLER
		QUALIFIER ALL, NONNEGATABLEE
		QUALIFIER FOLDER, VALUE(REQUIRED) 
		DISALLOW ALL AND DEFAULT
	DEFINE SYNTAX SET_BBOARDE
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"W
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=BB_USERNAMEW
		QUALIFIER EXPIRATION, VALUE(TYPE=$NUMBER)	
			LABEL=EXPIRATION, DEFAULT
		QUALIFIER SPECIAL, NONNEGATABLER
		QUALIFIER VMSMAIL, NONNEGATABLEB
		DISALLOW VMSMAIL AND NOT SPECIAL
		DISALLOW VMSMAIL AND NOT BB_USERNAME
	DEFINE SYNTAX SET_FOLDERL
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"G
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=SELECT_FOLDERU
		QUALIFIER MARKED, NONNEGATABLE
	DEFINE SYNTAX SET_NOACCESSS
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"F
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=ACCESS_ID, VALUE(LIST)
		PARAMETER P3, LABEL=ACCESS_FOLDERD
		QUALIFIER ALL, NONNEGATABLEE
		QUALIFIER READONLY, NONNEGATABLE
		DISALLOW NOT ALL AND NOT ACCESS_ID
		DISALLOW ALL AND NOT READONLY	
	DEFINE SYNTAX SET_ACCESSI
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"C
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=ACCESS_ID, VALUE(LIST)
		PARAMETER P3, LABEL=ACCESS_FOLDER 
		QUALIFIER READONLY, NONNEGATABLE
		QUALIFIER ALL, NONNEGATABLE 
		DISALLOW NOT ALL AND NOT ACCESS_ID
	DEFINE SYNTAX SET_PRIVILEGESa
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What" 
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=PRIVILEGES, PROMPT="Privileges"E
		VALUE (REQUIRED,LIST)O
	DEFINE SYNTAX SET_DEFAULT_EXPIREU
		PARAMETER P1, LABEL=SET_PARAM1, PROMPT="What"h
			VALUE(REQUIRED, TYPE=SET_OPTIONS)
		PARAMETER P2, LABEL=DEFAULT_EXPIRE, VALUE(TYPE=$NUMBER,REQUIRED)
	DEFINE VERB SHOWA
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS) 
!E
! The following are defined to allow qualifiers to be specifiedE
! directly after the SHOW command, i.e. SHOW/FULL FOLDER.L
! Otherwise, the CLI routines will reject the command, because itE
! first attempts to process the qualifier before process the parameter, 
! so it has no information the qualifiers are valid.
! 
		QUALIFIER FULL, SYNTAX=SHOW_FOLDER_FULL, NONNEGATABLEE
		QUALIFIER ALL, SYNTAX=SHOW_USERL
		QUALIFIER LOGIN, SYNTAX=SHOW_USERB
		QUALIFIER NOLOGIN, SYNTAX=SHOW_USERA
		QUALIFIER PRINT, SYNTAX=SHOW_KEYPAD_PRINTL
	DEFINE TYPE SHOW_OPTIONST
		KEYWORD FOLDER, SYNTAX=SHOW_FOLDER
		KEYWORD NEW, SYNTAX=SHOW_FLAGS
		KEYWORD PRIVILEGES, SYNTAX=SHOW_FLAGS"
		KEYWORD FLAGS, SYNTAX=SHOW_FLAGS
		KEYWORD KEYPAD, SYNTAX=SHOW_KEYPAD
		KEYWORD USER, SYNTAX=SHOW_USER
		KEYWORD VERSIONM
	DEFINE SYNTAX SHOW_FLAGST
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)B
	DEFINE SYNTAX SHOW_KEYPAD
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)L
		QUALIFIER PRINTU
	DEFINE SYNTAX SHOW_KEYPAD_PRINT
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)I
		QUALIFIER PRINT,DEFAULTB
	DEFINE SYNTAX SHOW_FOLDER
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)L
		PARAMETER P2, LABEL=SHOW_FOLDERU
	DEFINE SYNTAX SHOW_USER
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)U
		PARAMETER P2, LABEL=USERNAME
		QUALIFIER ALLN
		QUALIFIER LOGINA
		QUALIFIER NOLOGINT
		DISALLOW (NOLOGIN OR LOGIN OR ALL) AND USERNAMEE
		DISALLOW (LOGIN AND NOLOGIN)
	DEFINE SYNTAX SHOW_FOLDER_FULLF
		QUALIFIER FULL, DEFAULTL
		PARAMETER P1, LABEL=SHOW_PARAM1, PROMPT="What"
			VALUE(REQUIRED, TYPE=SHOW_OPTIONS)
		PARAMETER P2, LABEL=SHOW_FOLDER
	DEFINE VERB MARK
		PARAMETER P1, LABEL=NUMBER, VALUE(LIST,TYPE=$NUMBER)
        DEFINE VERB SPAWNU
		PARAMETER P1, LABEL=COMMAND, VALUE(TYPE=$REST_OF_LINE)
	DEFINE VERB UNMARKA
		PARAMETER P1, LABEL=NUMBER, VALUE(LIST,TYPE=$NUMBER)
	DEFINE VERB UNDELETEL
		PARAMETER P1, LABEL=BULLETIN_NUMBER, VALUE(TYPE=$FILE)
$eod P
$copy sys$input BULLETIN.CLD
$deckL
!N
!  This file is the CLD file used to define a command to execute
!  BULLETIN by using CDU, which adds the command  to the command table.A
!  The alternative is to define a symbol to execute BULLETIN.E
!  Either way will work, and it is up to the user's to decide whichO
!  method to work.  (If you don't know which, you probably should useB
!  the default symbol method.)
!O

Define Verb BULLETIN
  Image BULL_DIR:BULLETIND
  Parameter P1, Label = SELECT_FOLDERL
  Qualifier BBOARD
  Qualifier BULLCP
  Qualifier CLEANUP, Value (Required)T
  Qualifier EDIT
  Qualifier KEYPAD
  Qualifier LOGINO
  Qualifier MARKED
  Qualifier PAGE, DefaultD
  Qualifier PROMPT, Value (Default = "BULLETIN"), Default	
  Qualifier READNEWN
  Qualifier REVERSE 
  ! 
  ! The following line causes a line to be outputted separating system notices.F
  ! The line consists of a line of all "-"s, i.e.:
  !--------------------------------------------------------------------------F
  ! If you want a different character to be used, simply put in the desired oneI
  ! in the following line.  If you want to disable the feature, remove the
  ! Default at the end of the line.  (Don't remove the whole line!)E
  !	
  Qualifier SEPARATE, Value (Default = "-"), Default
  Qualifier STARTUPE
  Qualifier STOP
  Qualifier SYSTEM, Value (Type = $NUMBER, Default = "7")L
$eod L
$copy sys$input BULLETIN.COM
$deck
$ DEFINE SYS$INPUT SYS$NET
$ BULLETIN
$eod E
$copy sys$input BULLMAIN.CLD
$deckS
	MODULE BULLETIN_MAINCOMMANDSA
	DEFINE VERB BULLETIN	
		PARAMETER P1, LABEL=SELECT_FOLDER	
		QUALIFIER BBOARD
		QUALIFIER BULLCP
		QUALIFIER CLEANUP, LABEL=CLEANUP, VALUE(REQUIRED)Y
		QUALIFIER EDIT
		QUALIFIER KEYPAD
		QUALIFIER LOGINP
		QUALIFIER MARKED
		QUALIFIER PAGE, DEFAULTI
		QUALIFIER READNEWT
		QUALIFIER REVERSE,
!N
! The following line causes a line to be outputted separating system notices.=
! The line consists of a line of all "-"s, i.e.:
!--------------------------------------------------------------------------S
! If you want a different character to be used, simply put in the desired oneS
! in the following line.  If you want to disable the feature, remove the
! DEFAULT at the end of the line.  (Don't remove the whole line!)W
! 
		QUALIFIER SEPARATE, VALUE(DEFAULT="-"), DEFAULTY
		QUALIFIER STARTUPE
		QUALIFIER STOP
		QUALIFIER SYSTEM, VALUE(TYPE=$NUMBER,DEFAULT="7")
$eod R
$copy sys$input BULLSTART.COME
$deck	
$ RUN SYS$SYSTEM:INSTALL
BULL_DIR:BULLETIN/SHAR/OPEN/HEAD/-
PRIV=(OPER,SYSPRV,CMKRNL,WORLD,DETACH,PRMMBX,SYSNAM)
/EXIT	
$ BULL*ETIN :== $BULL_DIR:BULLETIN
$ BULLETIN/STARTUP
$eod E
$copy sys$input CREATE.COM
$deckY
$ FORTRAN/EXTEND BULLETIN	
$ FORTRAN/EXTEND BULLETIN0
$ FORTRAN/EXTEND BULLETIN1
$ FORTRAN/EXTEND BULLETIN2
$ FORTRAN/EXTEND BULLETIN3
$ FORTRAN/EXTEND BULLETIN4
$ FORTRAN/EXTEND BULLETIN5
$ FORTRAN/EXTEND BULLETIN6
$ FORTRAN/EXTEND BULLETIN7
$ FORTRAN/EXTEND BULLETIN8
$ FORTRAN/EXTEND BULLETIN9
$ MAC ALLMACSU
$ SET COMMAND/OBJ BULLCOMX
$ SET COMMAND/OBJ BULLMAIN
$ IF F$SEARCH("BULL.OLB") .NES. "" THEN DELETE BULL.OLB;
$ IF F$SEARCH("BULL.OLB") .EQS. "" THEN LIB/CREATE BULLI
$ LIB BULL *.OBJ;N
$ DELETE *.OBJ;*
$ @BULLETIN.LNKN
$eod (
$copy sys$input DCLREMOTE.COM 
$deckS
$! DCL procedure to execute DCL commands passed over Decnet on a remote system.T
$! Commands sent by the command procedure REMOTE.COM on the local system are
$! are received by this procedure on the remote node. 
$! This procedure is usually a DECNET OBJECT with task name DCLREMOTE andE
$! normally resides in the default DECNET account.  To install as an object,
$! enter NCP, and then use the command:1
$!		NCP> SET OBJECT DCLREMOTE FILE file-spec NUM 0
$! where file-spec includes the disk, directory, and file name of the file.N
$! If DCLREMOTE is not installed as an object, the logical name DCLREMOTE can
$! be defined to point at it.  T
$!
$! Alternativley, DCLREMOTE.COM could be placed in the directory of the user's
$! proxy login on the remote system.
$!
$! WARNING: An EXIT command must not be passed as a command to execute at this
$! procedure level or the link will hang.U
$!
$ SET NOON
$ N = 0A
$AGAIN:F
$ N = N + 1 
$ IF N .GE. 5 THEN GOTO DONE
$ OPEN/WRITE/READ/ERR=AGAIN NET SYS$NET	
$ DEFINE /NOLOG SYS$OUTPUT NET
$ DEFINE /NOLOG SYS$ERROR NETE
$NEXT_CMD:
$  READ /ERR=DONE NET COMMAND$
$  'COMMAND'
$  WRITE/ERR=DONE SYS$OUTPUT "COMMAND$DONE ''$STATUS'"
$  GOTO NEXT_CMD
$DONE:
$ CLOSE NETB
$eod A
$copy sys$input INSTALL.COM
$deckL
$ COPY BULLETIN.EXE BULL_DIR:
$ RUN SYS$SYSTEM:INSTALL
BULL_DIR:BULLETIN/DEL=
BULL_DIR:BULLETIN/SHAR/OPEN/HEAD/-
PRIV=(OPER,SYSPRV,CMKRNL,WORLD,DETACH,PRMMBX,SYSNAM)
/EXITL
$!
$! NOTE: BULLETIN requires a separate help library. If you do not wish
$! the library to be placed in SYS$HELP, modify the following lines andP
$! define the logical name BULL_HELP to be the help library directory, i.e.C
$!	$ DEFINE/SYSTEM BULL_HELP SYSD$:[NEWDIRECTORY]L
$! The above line should be placed in BULLSTART.COM to be executed after
$! every system reboot.	
$!
$ IF F$SEARCH("SYS$HELP:BULL.HLB") .NES. "" THEN LIB/DELETE=*/HELP SYS$HELP:BULL
$ IF F$SEARCH("SYS$HELP:BULL.HLB") .EQS. "" THEN LIB/CREATE/HELP SYS$HELP:BULL
$ LIB/HELP SYS$HELP:BULL BULLCOMS1,BULLCOMS2
$ LIB/HELP SYS$HELP:HELPLIB BULLETIN
$eod N
$copy sys$input INSTALL_REMOTE.COM
$deckS
$!
$! INSTALL_REMOTE.COMI
$! VERSION 5/25/88
$!
$! DESCRIPTION:1
$! Command procedure to easily install BULLETIN.EXE on several nodes. 
$!
$! INPUTS:
$! The following parameters can be added to the command line.  TheyD
$! should be placed on the command line which executes this commandV
$! procedure, separated by spaces.  I.e. @INSTALL_REMOTE.COM OLD COPY TEST
$!
$! OLD 	- Specifies that the present version of BULLETIN is 1.51 or earlier.
$! COPY - Specifies that the executable is to be copied to the nodes.n
$! TEST - Specifies that all the nodes are to be checked to see if theyS
$!	  are up before beginning the intallation.s
$!
$! NOTES:i
$! 	***PLEASE READ ALL COMMENTS BEFORE RUNNING THIS***
$! This calls REMOTE.COM which is also included with the installation.
$!
$! DCLREMOTE.COM must be properly installed on all nodes. 
$! See comments at the beginning of that file for instructions.H
$! Also, you need to have a proxy login with privileges on those nodes.A
$! This procedure assumes that the BULLETIN executable on each node is
$! located in the BULL_DIR directory.  The new executable should be copied
$! to that directory before running this procedure, or the COPY option
$! should be used.
$!
$! If the present version of BULLETIN is 1.51 or earlier, it does not have
$! the ability of setting BULL_DISABLE to disable BULLETIN, so you shouldO
$! use the OLD parameter when running this procedure.F
$!
$! INSTRUCTIONS FOR SPECIFYING THE NODES AT YOUR SITE:
$! Place the nodes where bulletin is to be reinstalled in variable NODES.D
$! Place the nodes where the executable is to be copied to in COPY_NODES.W
$! Place nodes where BULLCP is running in BULLCP_NODES. 
$!
$ NODES = "ALCVAX,NERUS,ANANSI,MOLVAX,LAURIE,CANDLE,KLYPSO,DOME" +-R
",ARVON,LARAN,ORYANA,PALDAR,MOTHRA,TARNA,DARIUS"
$ COPY_NODES = "NERUS,LAURIE,ARVON"F
$ BULLCP_NODES = "NERUS,LAURIE,ARVON"A
$!
$ NODES = NODES + ",",
$ COPY_NODES = COPY_NODES + ",",
$ BULLCP_NODES = BULLCP_NODES + "," 
$!
$! Check for any parameters passed to the command procedure.
$!
$ PARAMETER = P1 + P2 + P3
$ OLD = 0L
$ IF F$LOCATE("OLD",PARAMETER) .NE. F$LENGTH(PARAMETER) THEN OLD = 1
$ TEST = 0
$ IF F$LOCATE("TEST",PARAMETER) .NE. F$LENGTH(PARAMETER) THEN TEST = 1
$ COPYB = 0L
$ IF F$LOCATE("COPY",PARAMETER) .NE. F$LENGTH(PARAMETER) THEN COPYB = 1F
$!
$! If TEST requested, see if nodes are accessible.
$!
$ IF .NOT. TEST THEN GOTO END_TEST
$BEGIN_TEST:
$ NODES1 = NODES
$TEST:
$ IF F$LEN(NODES1) .EQ. 0 THEN GOTO END_TEST
$ NODE = F$EXTRACT(0,F$LOCATE(",",NODES1),NODES1))
$ NODES1 = NODES1 - NODE - ","
$ @REMOTE 'NODE' END
$ GOTO TESTL
$END_TEST:
$!
$! If COPY requested, copy executable to nodes.
$!
$ IF .NOT. COPYB THEN GOTO END_COPYn
$COPY:
$ IF F$LEN(COPY_NODES) .EQ. 0 THEN GOTO END_COPY
$ NODE = F$EXTRACT(0,F$LOCATE(",",COPY_NODES),COPY_NODES)i
$ COPY_NODES = COPY_NODES - NODE - ","
$ COPY BULLETIN.EXE 'NODE'::BULL_DIR:u
$ GOTO COPY'
$END_COPY:
$!
$! The procedure now goes to each node and disables bulletin and kills
$! the BULLCP process if present.  NOTE: If version is < 1.51, we assume
$! that BULLCP is running under SYSTEM account.  This is not necessary
$! for older versions where the BULLETIN/STOP command can be used.
$! If BULLCP is not running under the SYSTEM account for version 1.51K
$! or less, you will have to kill them manually before running this!
$!
$BEGIN_DISABLE:
$ NODES1 = NODES
$DISABLE:f
$ IF F$LEN(NODES1) .EQ. 0 THEN GOTO END_DISABLE 
$ NODE = F$EXTRACT(0,F$LOCATE(",",NODES1),NODES1)
$ NODES1 = NODES1 - NODE - ","
$ @REMOTE 'NODE' CONTINUE SET PROC/PRIV=ALL-
$ IF F$LOCATE(","+NODE+",",","+BULLCP_NODES) .EQ. -
 F$LENGTH(","+BULLCP_NODES) THEN GOTO SKIP_STOP_BULLCP
$ IF OLD THEN @REMOTE 'NODE' CONTINUE SET UIC [SYSTEM]
$ IF OLD THEN @REMOTE 'NODE' CONTINUE STOP BULLCPe
$ IF .NOT. OLD THEN @REMOTE 'NODE' CONTINUE BULLETIN := $BULL_DIR:BULLETIN
$ IF .NOT. OLD THEN @REMOTE 'NODE' CONTINUE BULLETIN/STOP 
$SKIP_STOP_BULLCP:
$ @REMOTE 'NODE' CONTINUE INS := $SYS$SYSTEM:INSTALL
$ IF OLD THEN @REMOTE 'NODE' END INS BULL_DIR:BULLETIN/DELETEE
$ IF .NOT. OLD THEN @REMOTE 'NODE' END DEF/SYSTEM BULL_DISABLE DISABLE
$ GOTO DISABLE
$END_DISABLE:C
$!
$! The procedure now installs the new BULLETIN.E
$!
$ NODES1 = NODES
$INSTALL:A
$ IF F$LEN(NODES1) .EQ. 0 THEN EXITL
$ NODE = F$EXTRACT(0,F$LOCATE(",",NODES1),NODES1) 
$ NODES1 = NODES1 - NODE - ","
$ @REMOTE 'NODE' CONTINUE SET PROC/PRIV=ALL 
$ @REMOTE 'NODE' CONTINUE INS := $SYS$SYSTEM:INSTALL
$ @REMOTE 'NODE' CONTINUE BULLETIN := $BULL_DIR:BULLETIN
$ IF OLD THEN @REMOTE 'NODE' CONTINUE INS BULL_DIR:BULLETIN/SHAR-l
/OPEN/HEAD/PRIV=(OPER,SYSPRV,CMKRNL,WORLD,DETACH,PRMMBX,SYSNAM)-
$ IF .NOT. OLD THEN @REMOTE 'NODE' CONTINUE INS BULL_DIR:BULLETIN/REPLACEi
$ IF .NOT. OLD THEN @REMOTE 'NODE' CONTINUE DEASS/SYSTEM BULL_DISABLEd
$ IF F$LOCATE(","+NODE+",",","+BULLCP_NODES) .EQ. -o
 F$LENGTH(","+BULLCP_NODES) THEN GOTO SKIP_START_BULLCPF
$ @REMOTE 'NODE' CONTINUE SET UIC [SYSTEM]
$ @REMOTE 'NODE' CONTINUE BULLETIN := $BULL_DIR:BULLETIN" 
$ @REMOTE 'NODE' CONTINUE BULLETIN/START
$SKIP_START_BULLCP:T
$ @REMOTE 'NODE' END CONTINUET
$ GOTO INSTALL
$eod L
$copy sys$input INSTRUCT.COM
$deckS
$ BULLETIN
ADD/PERMANENT/SYSTEM INSTRUCT.TXT
INFO ON HOW TO USE THE BULLETIN UTILITY.
ADD/PERMANENT NONSYSTEM.TXTy
INFO ON BEING PROMPTED TO READ NON-SYSTEM BULLETINS.
EXIT
$eod X
$copy sys$input LOGIN.COMX
$deckL
$!
$! The following line defines the BULLETIN command.E
$!
$ BULL*ETIN :== $BULL_DIR:BULLETIN
$!
$! Note: The command prompt when executing the utility is named after7
$! the executable image.  Thus, as it is presently set up, the promptU
$! will be "BULLETIN>".  DO NOT make the command that executes the
$! image different from the image name, or certain things will break."
$!
$! If you would rather define the BULLETIN command using CDU rather than
$! defining it using a symbol, use the BULLETIN.CLD file to do so.
$!
$! The following line causes new messages to be displayed upon logging in.
$!
$ BULLETIN/LOGIN/REVERSE
$!
$! If you wish bulletins to be displayed starting with
$! the newest rather the oldest, omit the /REVERSE qualifier.l
$! Note that for totally new users, only permanent system messages and
$! the first non-system general message is displayed (which, if you ran 
$! INSTURCT.COM, would describe what a non-system message is).
$! This is done so as to avoid overwhelming a new user with lots of 
$! messages upon logging in for the first time.l
$!
$eod j
$copy sys$input MAKEFILE.M
$deck
# Makefile for BULLETINa

Bulletin : Bulletin.Exe Bull.Hlb

Bulletin.Exe : Bull.Olbn
   Link /NoTrace Bull.Olb/Lib /Inc=Bulletin$Main,Sys$System:Sys.Stb/Sel -W
        /NoUserlib /Exe=Bulletin.Exe,Sys$Input/Opt
   ID="V1.68" $ 

Bull.Olb : Bulletin.Obj Bulletin0.Obj Bulletin1.Obj Bulletin2.Obj  \
           Bulletin3.Obj Bulletin4.Obj Bulletin5.Obj Bulletin6.Obj \
           Bulletin7.Obj Bulletin8.Obj Bulletin9.Obj \
           Bullcom.Obj Bullmain.Obj Allmacs.Obj
   Library /Create Bull.Olb *.Obj'
   Purge /Log *.Obj,*.Exe 

Bulletin.Obj : Bulletin.For Bullfiles.Inc Bulldir.Inc Bullfolder.Inc \
               Bulluser.IncN
   Fortran /Extend /NoList Bulletin.ForU

Bulletin0.Obj : Bulletin0.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \I
                Bullfiles.IncS
   Fortran /Extend /NoList Bulletin0.For

Bulletin1.Obj : Bulletin1.For Bulldir.Inc Bullfolder.Inc Bulluser.Inc \o
                Bullfiles.Inca
   Fortran /Extend /NoList Bulletin1.For

Bulletin2.Obj : Bulletin2.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \r
                Bullfiles.IncL
   Fortran /Extend /NoList Bulletin2.For

Bulletin3.Obj : Bulletin3.For Bulldir.Inc Bullfolder.Inc Bulluser.Inc \e
                Bullfiles.IncS
   Fortran /Extend /NoList Bulletin3.For

Bulletin4.Obj : Bulletin4.For Bullfolder.Inc Bulluser.Inc Bullfiles.Inc \C
                Bulldir.IncI
   Fortran /Extend /NoList Bulletin4.For

Bulletin5.Obj : Bulletin5.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \E
                Bullfiles.IncM
   Fortran /Extend /NoList Bulletin5.For

Bulletin6.Obj : Bulletin6.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \d
                Bullfiles.Incl
   Fortran /Extend /NoList Bulletin6.For

Bulletin7.Obj : Bulletin7.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \i
                Bullfiles.Inca
   Fortran /Extend /NoList Bulletin7.For

Bulletin8.Obj : Bulletin8.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \i
                Bullfiles.Incp
   Fortran /Extend /NoList Bulletin8.For

Bulletin9.Obj : Bulletin9.For Bulldir.Inc Bulluser.Inc Bullfolder.Inc \t
                Bullfiles.Inco
   Fortran /Extend /NoList Bulletin9.For

Allmacs.Obj : Allmacs.marC
   Macro   /NoList Allmacs.Mar

Bullcom.Obj : Bullcom.cldh
   Set Command /Obj Bullcom.Cldl

Bullmain.Obj : Bullmain.clds
   Set Command /Obj Bullmain.Cld

Bull.Hlb : Bullcoms1.Hlp Bullcoms2.Hlp
   Library /Create /Help Bull.Hlb Bullcoms1.Hlp, Bullcoms2.Hlp
   Purge Bull.Hlbe
*.hlb :e
        lib/help/cre $*r
$eod e
$copy sys$input REMOTE.COM
$decka
$! FILE: REMOTE.COM	VERSION 1.3	EDIT 880513 - CAKT
$! DCL procedure to execute DCL commands on a remote decnet node.n
$! The remote DECNET object DCLREMOTE.COM must be defined as a known type 0 
$! object on the remote node or the file must be in the login directoryi
$! of the account used on the remote system. Or the logical name DCLREMOTE
$! can be defined to point at the object.
$!
$! Usage: 	REM*OTE :== @SYS$MANAGER:REMOTE [P1] [P2] ...
$!
$! P1 - Node name commands are to be executed on, including any access control.e
$!	If no access control is specified then a proxy login is attempted.e
$!	The you do not have an account on the remote system then the defaultE
$!	DECNET account is used.
$! P2 -	DCL command to execute on the remote system. Optional.
$! P3-P8 Additional parameters passed to the command (so quotes aren't needed)
$A
$ ON WARNING THEN GOTO ERROR
$ ON CONTROL_Y THEN GOTO ERROR
$ COMMAND := 'P2' 'P3' 'P4' 'P5' 'P6' 'P7' 'P8'e
$ IF P2 .EQS. "CONTINUE" THEN COMMAND = COMMAND - "CONTINUE"
$ IF P2 .EQS. "END" THEN COMMAND = COMMAND - "END"
$ NEXT_CMD = "NEXT_CMD"E
$ IF P2 .NES. "" THEN NEXT_CMD = "DONE"
$ P1 = P1 - "::"
$ 
$ IF F$LOG ("NET") .EQS. "" THEN GOTO OPEN_LINK
$ IF P2 .EQS. "CONTINUE" THEN GOTO NEXT_CMD 
$ IF P2 .EQS. "END" THEN GOTO NEXT_CMD
$OPEN_LINK:E
$ WRITE SYS$OUTPUT "Establishing DECNET link to node ''P1'..."
$ OPEN/WRITE/READ NET 'P1'::"TASK=DCLREMOTE"
$S
$NEXT_CMD:
$ IF P2 .EQS. "" THEN READ /ERR=ERROR/PROMPT="''P1'> " SYS$COMMAND COMMAND
$ IF F$EDIT(F$EXTR(0,1,COMMAND),"UPCASE") .EQS. "E" THEN GOTO DONE
$ WRITE NET COMMANDE
$LOOP:
$   READ/ERR=ERROR/TIME_OUT=10 NET LINEl
$   IF F$EXTR (0,12,LINE) .EQS. "COMMAND$DONE" THEN GOTO 'NEXT_CMD'F
$   WRITE SYS$OUTPUT LINEN
$   GOTO LOOP
$DONE:
$ IF P2 .EQS. "CONTINUE" THEN EXIT
$ IF F$LOG ("NET") .NES. "" THEN CLOSE NET
$ EXIT
$ERROR:Y
$ IF F$LOG ("NET") .NES. "" THEN CLOSE NET
$ STOP
$eod 
